[{"name": "app.py", "content": "import asyncio\nimport os\nimport pandas as pd\nimport re\nfrom datetime import date\nfrom datetime import datetime\nfrom pathlib import Path\nfrom utils import get_guides, almost_reverse_complement, editor_data, determine_mutation_type, process_guide_rnas, get_cloning_url\nfrom shiny import App, render, ui, reactive\nfrom shiny.types import ImgData\n\nimport numpy as np\n\nbases = {\"A\", \"C\", \"G\", \"T\"}\naccepted_bases = {\"A\", \"C\", \"G\", \"T\", \"-\"}\n\n\n# A card component wrapper.\ndef ui_card(title, id, *args):\n    return (\n        ui.div(\n            {\"class\": \"card mb-4\"},\n            ui.div(title, class_=\"card-header\"),\n            ui.div({\"class\": \"card-body\", \"id\" : id}, *args),\n        ),\n    )\n\napp_ui = ui.page_fluid(\n    {\"id\": \"main-content\"},\n    ui.output_image(\"display_logo\", inline=True),\n    ui.output_image(\"stanford_logo\", inline=True),\n    ui.br(),\n    ui.help_text(\n        '''Welcome to editABLE! We have designed this tool to help to determine the type of gene editing most appropriate for a single gene edit. We prioritize finding base \n        editing reagents, as they have higher reported editing efficiency. Under conditions where base editing is not currently possible, we provide a first pass analysis for \n        reagents needed for prime editing. Please refer to the following papers for more information on base and prime editing:'''\n    ),\n    ui.br(),\n    ui.br(),\n    ui.help_text(ui.tags.a('Komor AC, Kim YB, Packer MS, Zuris JA, Liu DR. Programmable editing of a target base in genomic DNA without double-stranded DNA cleavage. Nature. 2016;533(7603):420-424.', {'href' : 'https://pubmed.ncbi.nlm.nih.gov/27096365/', 'target' : '_blank'})),\n    ui.br(),\n    ui.br(),\n    ui.help_text(ui.tags.a('Gaudelli NM, Komor AC, Rees HA, et al. Programmable base editing of A\u2022T to G\u2022C in genomic DNA without DNA cleavage. Nature. 2017;551(7681):464-471.', {'href' : 'https://pubmed.ncbi.nlm.nih.gov/29160308/', 'target' : '_blank'})),\n    ui.br(),\n    ui.br(),\n    ui.help_text(ui.tags.a('Anzalone AV, Randolph PB, Davis JR, et al. Search-and-replace genome editing without double-strand breaks or donor DNA. Nature. 2019;576(7785):149-157.', {'href' : 'https://pubmed.ncbi.nlm.nih.gov/31634902/', 'target' : '_blank'})),\n    ui.br(),\n    ui.br(),\n    ui.help_text(ui.tags.a('Doman JL, Pandey S, Neugebauer ME, et al. Phage-assisted evolution and protein engineering yield compact, efficient prime editors. Cell. 2023;186(18):3983-4002.e26.', {'href' : 'https://pubmed.ncbi.nlm.nih.gov/37657419/', 'target' : '_blank'})),\n    ui.br(),\n    ui.br(),\n    ui_card(\n        \"How to use this app\",\n        \"how_to_app\",\n        ui.help_text(\n            '''In CRISPR editing experiments, one is trying to induce some change in a DNA sequence.\n             Therefore, you have an original sequence you are trying to change and a desired sequence \n             (what you want your sequence to look like after the CRISPR edit).'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"There are two ways to use this app:\"),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''1. If you want to find guides for a single CRISPR edit. For this use case, please enter \n            in your original sequence and desired sequence in their respective input boxes.'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''2. If you have more than one CRISPR edit you want to make, you can upload a CSV file with \n            two columns, named \"Original Sequence\" and \"Desired Sequence\" that contain your original and \n            desired sequences, with each row representing one edit you would like to make. Then click the \n            blue \"Upload File\" button even if the progress bar under the file browser says \"Upload complete\"'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''After specifing your input, click the \"Find Guides\" button and editABLE will try to find CRISPR \n            guides that will induce your desired edits. Once editABLE finishes running, a table will appear \n            displaying either the guides that editABLE has found for each of your desired edits or a suggestion to \n            use an alternative CRISPR technology if base or prime editing guides can't be found. Lastly, you can \n            download a CSV of the guides found by editABLE by clicking on the \"Download Results as CSV File\" \n            button. Base editing reagents will be suggested first due to their higher reported editing efficiency. \n            If a base editing guide cannot be found, we will then provide suggested prime editing reagents if possible.'''\n        )\n    ),\n    ui_card(\n        \"Input requirements\",\n        \"input_recs\",\n        ui.help_text(\n            '''Your original sequence(s) and the desired sequence(s) must be the same length. Only single edits \n            (SNV, insertion, deletion) are supported at this time. Only the following characters are allowed in the input\n            (\"A\", \"C\", \"G\", \"T\", \"a\", \"c\", \"g\", \"t\", \"-\"). All whitespace is allowed but will be removed before running our pipeline.\n            Your sequences need to be from 5' to 3'.'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''For single nucleotide variant (SNV) edits, the input sequences are the most straightforward. You can \n            input the original and desired sequences without modification. For example, this would be a valid set of inputs:'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Original Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"A\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Desired Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"T\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''For changes that result in deletions, use a string of \"-\" characters in the desired sequence to denote the \n            area of the deletion. For example, this would be a valid set of inputs for a deletion:'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Original Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"ATT\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Desired Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"---\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''For changes that result in insertions/duplications, use a string of \"-\" characters in the original sequence \n            to denote the area of the insertion/duplication. For example, this would be a valid set of inputs for a insertions/duplications:'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Original Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"---\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Desired Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"GCG\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''Then, use the \"Select Desired Base Editing PAM\" dropdown to select the base editing PAM that is desired.'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''Lastly, we require at least 25 base pairs of sequence to the left and right of your desired ''',\n            ui.tags.b(\"edit\", style=\"color: red\"),\n            '''. So in each of the examples above, there must be 25 or more base pairs to the right and left \n            of the ''',\n            ui.tags.b(\"red\", style=\"color: red\"),\n            ''' highlighted regions.'''\n        )\n    ),\n    ui_card(\n        \"Input\",\n        'input',\n        ui.input_text_area(\"ref_sequence_input\", \"Original Sequence\", placeholder=\"Enter sequence\", height=\"50%\", width=\"100%\"),\n        ui.input_text_area(\"edited_sequence_input\", \"Desired Sequence\", placeholder=\"Enter sequence\", height=\"50%\", width=\"100%\"),\n        ui.output_ui(\"ui_input_file\"),\n        ui.input_action_button(\"upload\", \"Upload File\", class_=\"btn-primary\"),\n        ui.output_ui(\"upload_status\"),\n        ui.br(),\n        ui.input_select(\"pam_type\", \"Select Desired Base Editing PAM\", {\"NGN\": \"NGN (Recommended)\", \"NGG\": \"NGG (Most Efficient)\", \"NGA\" : \"NGA\", \"NNGRRT\" : \"NNGRRT (SaCas9)\", \"NNNRRT\" : \"NNNRRT (SaCas9-KKH)\", \"NRN\" : \"NRN (SpRY)\"}),\n        ui.input_action_button(\"get_guides\", \"Find Guides\", class_=\"btn-primary\"),\n        ui.help_text(\" \"),\n        ui.input_action_button(\"clear\", \"Clear Inputs\", class_=\"btn-danger\"),\n    ),\n    ui.output_ui(\"run\"),\n    ui.br(),\n    ui.help_text(\n        '''For base editing, EditABLE finds guide RNAs where the editable base is in positions 4-9 starting from the 5' \n           end of the guide RNA. Note that guide RNAs with base edits outside of this editing range may still work but \n           tend to be significantly less efficient.'''\n    ),\n    ui.br(),\n    ui.br(),\n    ui.help_text(\n        '''Note that we use PrimeDesign (Hsu, J.Y., Gr\u00fcnewald, J., Szalay, R. et al. \n        PrimeDesign software for rapid and simplified design of prime editing guide RNAs. \n        Nat Commun 12, 1034 (2021)) for prime editing guide calcualtions. We run PrimeDesign \n        with default parameters and take only the suggested guides. For more advanced usage \n        please use the ''',\n        ui.tags.a('PrimeDesign portal', {'href' : 'https://primedesign.pinellolab.partners.org/', 'target' : '_blank'}),\n        ''' (https://primedesign.pinellolab.partners.org/) to design your Prime Editing guides.'''\n    ),\n    ui.br(),\n    ui.br(),\n    ui.help_text(\n        '''For troubleshooting and suggested revisions, please contact the ''',\n        ui.tags.a(\"Bhalla Lab\", {'href' : 'https://med.stanford.edu/bhallalab.html', 'target' : '_blank'}),\n        \" at vbhalla@stanford.edu\"\n    ),\n    ui.br(),\n    ui.br(),\n    ui.br(),\n    ui.br(),\n)\n\ndef check_ref_edited_pair(ref_sequence, edited_sequence):\n    if len(ref_sequence) == 0 or len(edited_sequence) == 0:\n        return False, \"Both the original sequence and the edited sequence must be of nonzero length.\"\n    if len(ref_sequence) != len(edited_sequence):\n        return False, \"The length of the original sequence and the edited sequence must be the same.\"\n    if ref_sequence == edited_sequence:\n        return False, \"The original sequence and the edited sequence are the same.\"\n    if len(set(ref_sequence) - accepted_bases) != 0 or len(set(edited_sequence) - accepted_bases) != 0:\n        return False, \"You may only have the following characters in your sequences {A, C, G, T, a, c, g, t, -}.\"\n    if len(set(ref_sequence) - bases) == 0 and len(set(edited_sequence) - bases) == 0:\n        substitution_position = None\n        for i in range(len(ref_sequence)):\n            ref_base = ref_sequence[i]\n            edited_base = edited_sequence[i]\n            if ref_base != edited_base:\n                if substitution_position is not None:\n                    return False, \"The original sequence and the edited sequence contain more than one SNV. EditABLE currently only supports single SNVs, insertions, or deletions.\"\n                else:\n                    substitution_position = i\n        if substitution_position < 25:\n            return False, f\"There must be at least 25 base pairs of sequence before the desired edit. {substitution_position} base pairs were found before your edit.\"\n        if len(ref_sequence) - 1 - substitution_position < 25:\n            return False, f\"There must be at least 25 base pairs of sequence after the desired edit. {len(ref_sequence) - 1 - substitution_position} base pairs were found after your edit.\"\n    else:\n        if '-' not in ref_sequence and '-' not in edited_sequence:\n            return False, 'The lengths of the original sequence and the edited sequence are not the same but neither has a \"-\" in it.'\n        if '-' in ref_sequence and '-' in edited_sequence:\n            return False, 'You cannot have a \"-\" in both the original and edited sequences.'\n        elif '-' in ref_sequence:\n            start_dash_position = None\n            current_dash_position = None\n            for i in range(len(ref_sequence)):\n                if ref_sequence[i] == '-':\n                    if start_dash_position is None:\n                        start_dash_position = i\n                    if current_dash_position is not None and i - current_dash_position != 1:\n                        return False, 'The \"-\" characters are not contiguous, indicating that there are multiple insertions. EditABLE currently only supports single SNVs, insertions, or deletions.'\n                    else:\n                        current_dash_position = i\n            if start_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence before the desired edit. {start_dash_position} base pairs were found before your edit.\"\n            if len(ref_sequence) - 1 - current_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence after the desired edit. {len(ref_sequence) - 1 - current_dash_position} base pairs were found after your edit.\"\n        else:\n            start_dash_position = None\n            current_dash_position = None\n            for i in range(len(edited_sequence)):\n                if edited_sequence[i] == '-':\n                    if start_dash_position is None:\n                        start_dash_position = i\n                    if current_dash_position is not None and i - current_dash_position != 1:\n                        return False, 'The \"-\" characters are not contiguous, indicating that there are multiple deletions. EditABLE currently only supports single SNVs, insertions, or deletions.'\n                    else:\n                        current_dash_position = i\n            if start_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence before the desired edit. {start_dash_position} base pairs were found before your edit.\"\n            if len(ref_sequence) - 1 - current_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence after the desired edit. {len(ref_sequence) - 1 - current_dash_position} base pairs were found after your edit.\"\n    return True, \"Inputs verified. Proceed to get guides.\"\n\n\ndef generate_experimental_validation_section(guides_df, pam_type):\n    # Extract the guide RNAs from the DataFrame\n    guide_rnas = guides_df[\"Base Editing Guide\"].tolist()\n    \n    # Process the guide RNAs\n    processed_guide_rnas = process_guide_rnas(guide_rnas)\n    \n    # Get the cloning URL based on PAM type\n    cloning_id, cloning_url = get_cloning_url(pam_type)\n    \n    # Create the validation section UI elements\n    validation_section = [\n        ui.help_text(\n            ui.tags.span(\"1. Order the following paired oligos from \"),\n            ui.tags.a(\"IDT\", href=\"https://www.idtdna.com\", target=\"_blank\"),\n            ui.tags.span(\" (or other preferred vendor).\")\n        ),\n        ui.br(),\n        ui.br(),\n    ]\n    \n    # Add each processed guide RNA to the validation section\n    for guide_rna in processed_guide_rnas:\n        guide_rna_parts = guide_rna.split('\\n')\n        for part in guide_rna_parts:\n            validation_section.append(ui.help_text(part))\n            validation_section.append(ui.br())\n        validation_section.append(ui.br())  # Add a double space between guide RNAs\n    \n    validation_section.extend([\n        ui.br(),\n        ui.help_text(\n            ui.tags.span(\"2. Purchase Guide RNA cloning plasmid from \"),\n            ui.tags.a(\"Addgene\", href=cloning_url, target=\"_blank\"),\n            ui.tags.span(f\" (Addgene: {cloning_id}).\")\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            ui.tags.span(\"3. Follow Cloning Protocol \"),\n            ui.tags.a(\"here\", href=\"https://media.addgene.org/cms/filer_public/6d/d8/6dd83407-3b07-47db-8adb-4fada30bde8a/zhang-lab-general-cloning-protocol-target-sequencing_1.pdf\", target=\"_blank\"),\n            ui.tags.span(\".\")\n        ),\n    ])\n    \n    return ui_card(\"Experimental Validation of Base Editing Guide RNAs\", 'validation_section', *validation_section)\n\ndef generate_base_editing_visualization(guides_df, ref_sequence_input, substitution_position, PAM):\n    list_of_guides_to_display = []\n    for index, row in guides_df.iterrows():\n        if row['Editing Technology'] == 'Base Editing':\n            guide = row[\"Base Editing Guide\"]\n            orientation = row[\"Base Editing Guide Orientation\"]\n\n            ref_sequence_almost_rc = almost_reverse_complement(ref_sequence_input)\n            base_to_edit = ref_sequence_input[substitution_position] if orientation != 'reverse' else ref_sequence_almost_rc[substitution_position]\n            if orientation == 'reverse':\n                guide = guide[::-1]\n                all_guide_occurance_starts = [m.start() for m in re.finditer(guide, ref_sequence_almost_rc)]\n            else:\n                all_guide_occurance_starts = [m.start() for m in re.finditer(guide, ref_sequence_input)]\n\n            true_starting_positions = []\n            for start in all_guide_occurance_starts:\n                end = start + len(guide) - 1\n                if substitution_position >= start and substitution_position <= end:\n                    true_starting_positions.append(start)\n            assert len(true_starting_positions) == 1, (\"Error! Guide cannot be aligned properly to input original sequence\", guide, ref_sequence_almost_rc, orientation, all_guide_occurance_starts, substitution_position)\n            guide_start = true_starting_positions[0]\n\n            list_of_guides_to_display.append(ui.help_text(f\"Guide {index + 1}\"))\n            list_of_guides_to_display.append(ui.br())\n            if orientation == 'reverse':\n                reverse_guide_rna_with_formatting = []\n                for i in range(len(guide)):\n                    base_position = guide_start + len(guide) - 1 - i\n                    base = ref_sequence_almost_rc[base_position]\n                    if i >= 3 and i < 9:  # Bases 4-9 (0-based index)\n                        if base_position == substitution_position:  # Base to edit\n                            reverse_guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: green; font-family: Courier,courier\"))\n                        elif base == base_to_edit:\n                            reverse_guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: red; font-family: Courier,courier\"))\n                        else:\n                            reverse_guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: violet; font-family: Courier,courier\"))\n                    else:\n                        reverse_guide_rna_with_formatting.append(ui.tags.b(base, style=\"color: violet; font-family: Courier,courier\"))\n\n                list_of_guides_to_display.append(\n                    ui.help_text(\n                        ui.tags.b(\"Forward Strand: 5'-\" + ref_sequence_input[:substitution_position], style=\"font-family: Courier,courier\"),\n                        ui.tags.b(ref_sequence_input[substitution_position], style=\"color: green; font-family: Courier,courier\"),  # base to edit\n                        ui.tags.b(ref_sequence_input[substitution_position + 1:] + \"-3'\", style=\"font-family: Courier,courier\"),\n                    )\n                )\n                list_of_guides_to_display.append(ui.br())\n                list_of_guides_to_display.append(\n                    ui.help_text(\n                        ui.tags.b(\"Reverse Strand: 3'-\" + ref_sequence_almost_rc[:guide_start - len(PAM)], style=\"font-family: Courier,courier\"),\n                        ui.tags.b(ref_sequence_almost_rc[guide_start - len(PAM):guide_start], style=\"color: blue; font-family: Courier,courier\"),  # PAM\n                        *reverse_guide_rna_with_formatting[::-1],  # reverse guide RNA\n                        ui.tags.b(ref_sequence_almost_rc[guide_start + len(guide):] + \"-5'\", style=\"font-family: Courier,courier\"),\n                    )\n                )\n            else:\n                guide_rna_with_formatting = []\n                for i in range(len(guide)):\n                    base = ref_sequence_input[guide_start + i]\n                    if i >= 3 and i < 9:  # Bases 4-9 (0-based index)\n                        if guide_start + i == substitution_position:  # Base to edit\n                            guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: green; font-family: Courier,courier\"))\n                        elif base == base_to_edit:\n                            guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: red; font-family: Courier,courier\"))\n                        else:\n                            guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: violet; font-family: Courier,courier\"))\n                    else:\n                        guide_rna_with_formatting.append(ui.tags.b(base, style=\"color: violet; font-family: Courier,courier\"))\n\n                list_of_guides_to_display.append(\n                    ui.help_text(\n                        ui.tags.b(\"Forward Strand: 5'-\" + ref_sequence_input[:guide_start], style=\"font-family: Courier,courier\"),\n                        *guide_rna_with_formatting,\n                        ui.tags.b(ref_sequence_input[len(guide) + guide_start:len(guide) + guide_start + len(PAM)], style=\"color: blue; font-family: Courier,courier\"),  # PAM\n                        ui.tags.b(ref_sequence_input[guide_start + len(guide) + len(PAM):] + \"-3'\", style=\"font-family: Courier,courier\"),\n                    )\n                )\n                list_of_guides_to_display.append(ui.br())\n                list_of_guides_to_display.append(\n                    ui.help_text(\n                        ui.tags.b(\"Reverse Strand: 3'-\" + ref_sequence_almost_rc[:substitution_position], style=\"font-family: Courier,courier\"),\n                        ui.tags.b(ref_sequence_almost_rc[substitution_position], style=\"color: green; font-family: Courier,courier\"),  # base to edit\n                        ui.tags.b(ref_sequence_almost_rc[substitution_position + 1:] + \"-5'\", style=\"font-family: Courier,courier\"),\n                    )\n                )\n            if index != guides_df.shape[0] - 1:\n                list_of_guides_to_display.append(ui.br())\n                list_of_guides_to_display.append(ui.br())\n    return list_of_guides_to_display\n\n\n\n\ndef server(input, output, session):\n    #Function to get editor info based on PAM and mutation type\n    def get_editor_info(pam_type, mutation_type):\n        return editor_data[mutation_type].get(pam_type, editor_data['PrimeEditor']['default'])\n\n    def input_check(ref_sequence_input, edited_sequence_input):\n        nonlocal input_file\n        if input_file and not (ref_sequence_input or edited_sequence_input):\n            try:\n                df = pd.read_csv(input_file)\n            except:\n                return False, \"Input file is not a properly formed CSV file. Please input a proper CSV file.\"\n\n            if len(df.columns) != 2 or df.columns.tolist() != ['Original Sequence', 'Desired Sequence']:\n                return False, 'Uploaded csv does not have the proper columns. Your csv must have two columns with names \"Original Sequence\" and \"Desired Sequence\"'\n            \n            counter = 1\n            for index, row in df.iterrows():\n                ref_sequence = \"\".join(row['Original Sequence'].split()).upper()\n                edited_sequence = \"\".join(row['Desired Sequence'].split()).upper()\n                check, message = check_ref_edited_pair(ref_sequence, edited_sequence)\n                if not check:\n                    return check, f\"Error row {counter}: {message}\"\n                counter += 1\n            return True, \"Input CSV verified. Proceed to get guides.\"\n        elif ref_sequence_input and edited_sequence_input and not input_file:\n            check, message = check_ref_edited_pair(\"\".join(ref_sequence_input.split()).upper(), \"\".join(edited_sequence_input.split()).upper())\n            return check, message\n        elif ref_sequence_input and edited_sequence_input and input_file:\n            return False, \"Error: Fill in both text input fields or upload a CSV file but do not do both.\"\n        else:\n            return False, \"Error: Fill in both text input fields or upload a CSV file.\"\n    \n    input_file = None\n\n    @output\n    @render.ui\n    @reactive.event(input.upload)\n    def upload():\n        nonlocal input_file\n        file_infos = input.file1()\n        if file_infos:\n            input_file = file_infos[0]['datapath']\n            return ui.div(ui.br(), ui.tags.b(\"File Successfully Uploaded\", style=\"color: grey;\", id='upload_status'))\n        else:\n            return ui.div(ui.br(), ui.tags.b(\"Error: No file selected\", style=\"color: red;\", id='upload_status'))\n\n    @reactive.Effect()\n    def clear():\n        value = input.clear()    \n        if value > 0:\n            ui.update_text_area(\"ref_sequence_input\", value = \"\")\n            ui.update_text_area(\"edited_sequence_input\", value = \"\")\n            ui.update_select(\"pam_type\", selected='NGN')\n            ui.remove_ui(selector=\"div:has(> #results)\")\n            ui.remove_ui(selector=\"div:has(> #upload_status)\")\n\n            nonlocal input_file\n            input_file = None\n\n    @output\n    @render.ui\n    def ui_input_file():\n        input.clear()  \n        return ui.input_file(f\"file1\", 'Choose a CSV File of Sequences to Upload (note that you must click the blue \"Upload File\" button even if the progress bar under the file browser says \"Upload complete\". Also, clicking the button will cause the screen to scroll up to the top which is annoying and we are trying to fix that):', accept='.csv', multiple=False, width=\"100%\"),\n        \n    @output\n    @render.ui\n    @reactive.event(input.get_guides)\n    def run():\n        ref_sequence_input = input.ref_sequence_input()\n        edited_sequence_input = input.edited_sequence_input()\n        PAM = input.pam_type()\n        mutation_type = determine_mutation_type(ref_sequence_input, edited_sequence_input)\n\n        editor_name, editor_id, editor_url = get_editor_info(PAM, mutation_type)\n        editor_info = f\"{editor_name} (Addgene: {editor_id}, {editor_url})\"\n        \n        to_display_guides_df, guides_df = get_guides(ref_sequence_input, edited_sequence_input, PAM)\n        base_editing_guides_df = guides_df[guides_df['Editing Technology'] == 'Base Editing']\n        prime_editing_guides_df = guides_df[guides_df['Editing Technology'] == 'Prime Editing']\n\n        @output\n        @render.data_frame\n        def render_results():\n            nonlocal to_display_guides_df\n            return render.DataGrid(\n                to_display_guides_df,\n                width=\"100%\",\n                filters=False,\n                summary=True,\n            )\n\n        @session.download(filename=lambda: f\"guides-{date.today().isoformat()}-{datetime.now().strftime('%H-%M-%S')}.csv\")\n        async def download_results():\n            nonlocal guides_df\n            yield guides_df.to_csv()\n\n        ref_sequence_input = input.ref_sequence_input()\n        edited_sequence_input = input.edited_sequence_input()\n\n        nonlocal input_file\n        valid_inputs, message = input_check(ref_sequence_input, edited_sequence_input)\n        PAM = input.pam_type()\n\n        if valid_inputs:\n            if input_file and not (ref_sequence_input or edited_sequence_input):\n                df = pd.read_csv(input_file)\n                dfs_to_merge_download = list()\n                dfs_to_merge_display = list()\n                counter = 1\n\n                with ui.Progress(min=1, max=df.shape[0] + 1) as p:\n                    p.set(message=\"Finding guides\", detail=\"This may take a while...\")\n                    for index, row in df.iterrows():\n                        p.set(counter, message=\"Finding guides\")\n                        ref_sequence_input = \"\".join(row['Original Sequence'].split()).upper()\n                        edited_sequence_input = \"\".join(row['Desired Sequence'].split()).upper()\n                        to_display_guides_df, guides_df = get_guides(ref_sequence_input, edited_sequence_input, PAM)\n                        index_column = [str(counter)] * to_display_guides_df.shape[0]\n                        to_display_guides_df.insert(loc=0, column='Input CSV Row Number', value=index_column)\n                        dfs_to_merge_download.append(guides_df)\n                        dfs_to_merge_display.append(to_display_guides_df)\n                        counter += 1\n\n                to_display_guides_df = pd.concat(dfs_to_merge_display)\n                to_display_guides_df = to_display_guides_df.drop(columns=['Original Sequence', 'Desired Sequence'])\n                guides_df = pd.concat(dfs_to_merge_download)\n                base_editing_guides_df = guides_df[guides_df['Editing Technology'] == 'Base Editing']\n                \n                ui_elements = [\n                    ui_card(\n                        \"Recommended Guide RNAs\",\n                        'results',\n                        ui.help_text(\n                            \"Note: for base editing, there can be more than one guide RNA for a single desired edit, but for prime editing, we will only show the recommended PrimeDesign guide RNA\"\n                        ),\n                        ui.br(),\n                        ui.br(),\n                        ui.output_data_frame(\"render_results\"),\n                        ui.br(),\n                        ui.br(),\n                    )\n                ]\n                \n                ui_elements.append(ui.download_button(\"download_results\", \"Download Results as CSV File\"))\n                ui_elements.append(ui.br())  # Add this line to insert a line break\n\n                return ui.TagList(*ui_elements)\n            elif ref_sequence_input and edited_sequence_input and not input_file:\n                ref_sequence_input = \"\".join(ref_sequence_input.split()).upper()\n                edited_sequence_input = \"\".join(edited_sequence_input.split()).upper()\n                to_display_guides_df, guides_df = get_guides(ref_sequence_input, edited_sequence_input, PAM)\n                to_display_guides_df = to_display_guides_df.drop(columns=['Original Sequence', 'Desired Sequence'])\n                to_display_guides_df.insert(loc=0, column='Guide', value=[f\"Guide {i + 1}\" for i in range(to_display_guides_df.shape[0])])\n\n                substitution_position = None\n                for i in range(len(ref_sequence_input)):\n                    ref_base = ref_sequence_input[i]\n                    edited_base = edited_sequence_input[i]\n                    if ref_base != edited_base:\n                        substitution_position = i\n                        break\n\n                if len(ref_sequence_input) > 51:\n                    ref_sequence_input = ref_sequence_input[substitution_position - 25:substitution_position + 25 + 1]\n                    substitution_position = 25\n\n                list_of_guides_to_display = generate_base_editing_visualization(guides_df, ref_sequence_input, substitution_position, PAM)\n\n                # Filter for Base Editing or Prime Editing guides only\n                filtered_guides_df = to_display_guides_df[to_display_guides_df['Editing Technology'].isin(['Base Editing', 'Prime Editing'])]\n\n                ui_elements = [\n                    ui_card(\n                        \"Recommended Guide RNAs\",\n                        'results',\n                        ui.help_text(\n                            \"Note: for base editing, there can be more than one guide RNA for a single desired edit, but for prime editing, we will only show the recommended PrimeDesign guide RNA. \"\n                        ),\n                        ui.br(),\n                        ui.br(),\n                        ui.output_data_frame(\"render_results\"),\n                        ui.br(),\n                    )\n                ]\n\n                if not filtered_guides_df.empty:\n                    ui_elements.append(\n                        ui_card(\n                            \"Recommended Editor\",\n                            \"recommended_editor\",\n                            ui.help_text(f\"Selected Editor: {editor_info}\"),\n                            ui.br(),\n                            ui.br(),\n                            ui.tags.a(\"View on Addgene\", href=editor_url, target=\"_blank\", class_=\"btn btn-primary\"),\n                        )\n                    )\n\n                if 'Base Editing' in filtered_guides_df['Editing Technology'].values:\n                    ui_elements.append(\n                        ui_card(\n                            \"Visualization of Base Editing Guides\",\n                            \"base_editing_visualization\",\n                            ui.help_text(\n                                \"For each base editing guide, your input will be displayed with the guide sequence highlighted on the appropriate strand.\",\n                                ui.tags.b(\" Green\", style=\"color: green\"),\n                                \" characters represent your edited base, \", \n                                ui.tags.b(\"blue\", style=\"color: blue\"),\n                                \" characters represent the PAM nucleotides, \",\n                                ui.tags.b(\"violet\", style=\"color: violet\"),\n                                \" characters represent other nucleotides in the guide, \",\n                                ui.tags.b(\"underlined\", style=\"text-decoration: underline\"),\n                                \" characters represent a span for potential bystander edits, and \",\n                                ui.tags.b(\"red\", style= \"color: red\"),\n                                \" characters represent the potential bystander edits, themselves. Grey characters represent nucleotides not spanned by the guide. Only 25 bp of sequence upstream and downstream of the desired edit is shown. NOTE: when toggling the order of the guides, the guide number above corresponds to the guide number within the visualization.\"\n                            ),\n                            ui.br(),\n                            ui.br(),\n                            *list_of_guides_to_display\n                        )\n                    )\n\n                if not base_editing_guides_df.empty:\n                    validation_section = generate_experimental_validation_section(base_editing_guides_df, PAM)\n                    ui_elements.append(validation_section)\n\n                ui_elements.append(ui.download_button(\"download_results\", \"Download Results as CSV File\"))\n                ui_elements.append(ui.br())  # Add this line to insert a line break\n\n                return ui.TagList(*ui_elements)\n        else:\n            return ui.div(ui.tags.b(message, style=\"color: red;\"))\n\n\n    @output\n    @render.image\n    def display_logo():\n        dir = Path(__file__).resolve().parent\n        img: ImgData = {\"src\": str(dir / \"EditABLE-logos_transparent.png\"), \"width\": \"300px\"}\n        return img\n\n    @output\n    @render.image\n    def stanford_logo():\n        dir = Path(__file__).resolve().parent\n        img: ImgData = {\"src\": str(dir / \"SOM_Web_vert_LG.png\"), \"width\": \"300px\"}\n        return img\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "EditABLE-logos_transparent.png", "content": "iVBORw0KGgoAAAANSUhEUgAABLAAAASwCAYAAADrIbPPAAAAAXNSR0IArs4c6QAAIABJREFUeF7s3QmUZVdZL/Bv36oGMnSdU92J8CJEwaeCiIhAhIjMM6hAkKciID4fIihhUCBdt0KRutUJKGFSfAjyCKAoQ2QMKCjhMckgagKiPiYhgISk77m3M0C66u63qsEBDKTOubeqTtX91Vq9Yrr3951v//ZeJPl7hxR+CBAgQIAAAQIECBAgQIAAAQIECLRYILV4NqMRIECAAAECBAgQIECAAAECBAgQCAGWS0CAAAECBAgQIECAAAECBAgQINBqAQFWq4/HcAQIECBAgAABAgQIECBAgAABAgIsd4AAAQIECBAgQIAAAQIECBAgQKDVAgKsVh+P4QgQIECAAAECBAgQIECAAAECBARY7gABAgQIECBAgAABAgQIECBAgECrBQRYrT4ewxEgQIAAAQIECBAgQIAAAQIECAiw3AECBAgQIECAAAECBAgQIECAAIFWCwiwWn08hiNAgAABAgQIECBAgAABAgQIEBBguQMECBAgQIAAAQIECBAgQIAAAQKtFhBgtfp4DEeAAAECBAgQIECAAAECBAgQICDAcgcIECBAgAABAgQIECBAgAABAgRaLSDAavXxGI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erjMRwBAgQIECBAgAABAgQIECBAgIAAyx0gQIAAAQIECBAgQIAAAQIECBBotYAAq9XHYzgCBAgQIECAAAECBAgQIECAAAEBljtAgAABAgQIECBAgAABAgQIECDQagEBVquPx3AECBAgQIAAAQIECBAgQIAAAQICLHeAAAECBAgQIECAAAECBAgQIECg1QICrFYfj+EIECBAgAABAgQIECBAgAABAgQEWO4AAQIECBAgQIAAAQIECBAgQIBAqwUEWK0+HsMRIECAAAECBAgQIECAAAECBAgIsNwBAgQIECBAgAABAgQIECBAgACBVgsIsFp9PIYjQIAAAQIECBAgQIAAAQIECBAQYLkDBAgQIECAAAECBAgQIECAAAECrRYQYLX6eAxHgAABAgQIECBAgAABAgQIECAgwHIHCBAgQIAAAQIECBAgQIAAAQIEWi0gwGr18RiOAAECBAgQIECAAAECBAgQIEBAgOUOECBAgAABAgQIECBAgAABAgQItFpAgNXq4zEcAQIECBAgQIAAAQIECBAgQICAAMsdIECAAAECBAgQIECAAAECBAgQaLWAAKvVx2M4AgQIECBAgAABAgQIECBAgAABAZY7QIAAAQIECBAgQIAAAQIECBAg0GoBAVarj8dwBAgQIECAAAECBAgQIECAAAECAix3gAABAgQIECBAgAABAgQIECBAoNUCAqxWH4/hCBAgQIAAAQIECBAgQIAAAQIEBFjuAAECBAgQIECAAAECBAgQIECAQKsFBFitPh7DESBAgAABAgQIECBAgAABAgQICLDcAQIECBAgQIAAAQIECBAgQIAAgVYLCLBafTyGI0CAAAECBAgQIECAAAECBAgQEGC5AwQIECBAgAABAgQIECBAgAABAq0WEGC1+ngMR4AAAQIECBAgQIAAAQIECBAgIMByBwgQIECAAAECBAgQIECAAAECBFotIMBq9fEYjgABAgQIECBAgAABAgQIECBAQIDlDhAgQIAAAQIECBAgQIAAAQIECLRaQIDV6uMxHAECBAgQIECAAAECBAgQIECAgADLHSBAgAABAgQIECBAgAABAgQIEGi1gACr1cdjOAIECBAgQIAAAQIECBAgQIAAAQGWO0CAAAECBAgQIECAAAECBAgQINBqAQFWq4/HcAQIECBAgAABAgQIECBAgAABAgIsd4AAAQIECBAgQIAAAQIECBAgQKDVAgKsVh+P4QgQIECAAAECBAgQIECAAAECBARY7gABAgQIECBAgAABAgQIECBAgECrBQRYrT4ewxEgQIAAAQIECBAgQIAAAQIECAiw3AECBAgQIECAAAECBAgQIECAAIFWCwiwWn08hiNAgAABAgQIECBAgAABAgQIEBBguQMECBAgQIAAAQIECBAgQIAAAQKtFhBgtfp4DEeAAAECBAgQIECAAAECBAgQICDAcgcIECBAgAABAgQIECBAgAABAgRaLSDAavXxGI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erjMRwBAgQIECBAgAABAgQIECBAgIAAyx0gQIAAAQIECBAgQIAAAQIECBBotYAAq9XHYzgCBAgQIECAAAECBAgQIECAAAEBljtAgAABAgQIECBAgAABAgQIECDQagEBVquPx3AECBAgQIAAAQIECBAgQIAAAQICLHeAAAECBAgQIECAAAECBAgQIECg1QICrFYfj+EIECBAgAABAgQIECBAgAABAgQEWO4AAQIECBAgQIAAAQIECBAgQIBAqwUEWK0+HsMRIECAAAECBAgQIECAAAECBAgIsNwBAgQIECBAgAABAgQIECBAgACBVgsIsFp9PIYjQIAAAQIECBAgQIAAAQIECBAQYLkDBAgQIECAAAECBAgQIECAAAECrRYQYLX6eAxHgAABAgQIECBAgAABAgQIECAgwHIHCBAgQIAAAQIECBAgQIAAAQIEWi0gwGr18RiOAAECBAgQIECAAAECBAgQIEBAgOUOECBAgAABAgQIECBAgAABAgQItFpAgNXq4zEcAQIECBAgQIAAAQIECBAgQICAAMsdIECAAAECBAgQIECAAAECBAgQaLWAAKvVx2M4AgQIECBAgAABAgQIECBAgAABAZY7QIAAAQIECBAgQIAAAQIECBAg0GoBAVarj8dwBAgQIECAAAECBAgQIECAAAECAix3gAABAgQIECBAgAABAgQIECBAoNUCAqxWH4/hCBAgQIAAAQIECBAgQIAAAQIEBFjuAAECBAgQIECAAAECBAgQIECAQKsFBFitPh7DESBAgAABAgQIECBAgAABAgQICLDcAQIECBAgQIAAAQIECBAgQIAAgVYLCLBafTyGI0CAAAECBAgQIECAAAECBAgQEGC5AwQIECBAgAABAgQIECBAgAABAq0WEGC1+ngMR4AAAQIECBAgQIAAAQIECBAgIMByBwgQIECAAAECBAgQIECAAAECBFotIMBq9fEYjgABAgQIECBAgAABAgQIECBAQIDlDhAgQIAAAQIECBAgQIAAAQIECLRaQIDV6uMxHAECBAgQIECAAAECBAgQIECAgADLHSBAgAABAgQIECBAgAABAgQIEGi1gACr1cdjOAIECBAgQIAAAQIECBAgQIAAAQGWO0CAAAECBAgQIECAAAECBAgQINBqAQFWq4/HcAQIECBAgAABAgQIECBAgAABAgIsd4AAAQIECBAgQIAAAQIECBAgQKDVAgKsVh+P4QgQIECAAAECBAgQIECAAAECBARY7gABAgQIECBAgAABAgQIECBAgECrBQRYrT4ewxEgQIAAAQIECBAgQIAAAQIECAiw3AECBAgQIECAAAECBAgQIECAAIFWCwiwWn08hiNAgAABAgQIECBAgAABAgQIEBBguQMECBAgQIAAAQIECBAgQIAAAQKtFhBgtfp4DEeAAAECBAgQIECAAAECBAgQICDAcgcIECBAgAABAgQIECBAgAABAgRaLSDAavXxGI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erjMRwBAgQIECBAgAABAgQIECBAgIAAyx0gQIAAAQIECBAgQIAAAQIECBBotYAAq9XHYzgCBAgQIECAAAECBAgQIECAAAEBljtAgAABAgQIECBAgAABAgQIECDQagEBVquPx3AECBAgQIAAAQIECBAgQIAAAQICLHeAAAECBAgQIECAAAECBAgQIECg1QICrFYfj+EIECBAgAABAgQIECBAgAABAgQEWO4AAQIECBAgQIAAAQIECBAgQIBAqwUEWK0+HsMRIECAAAECBAgQIECAAAECBAgIsNwBAgQIECBAgAABAgQIECBAgACBVgsIsFp9PIYjQIAAAQIECBAgQIAAAQIECBAQYLkDBAgQIECAAAECBAgQIECAAAECrRYQYLX6eAxHgAABAgQIECBAgAABAgQIECAgwHIHCBAgQIAAAQIECBAgQIAAAQIEWi0gwGr18RiOAAECBAgQIECAAAECBAgQIEBAgOUOECBAgAABAgQIECBAgAABAgQItFpAgNXq4zEcAQIECBAgQIAAAQIECBAgQICAAMsdIECAAAECBAgQIECAAAECBAgQaLWAAKvVx2M4AgQIECBAgAABAgQIECBAgAABAZY7QIAAAQIECBAgQIAAAQIECBAg0GoBAVarj8dwBAgQIECAAAECBAgQIECAAAECAix3gAABAgQIECBAgAABAgQIECBAoNUCAqxWH4/hCBAgQIAAAQIECBAgQIAAAQIEBFjuAAECBAgQIECAAAECBAgQIECAQKsFBFitPh7DESBAgAABAgQIECBAgAABAgQICLDcAQIECBAgQIAAAQIECBAgQIAAgVYLCLBafTyGI0CAAAECBAgQIECAAAECBAgQEGC5AwQIECBAgAABAgQIECBAgAABAq0WEGC1+ngMR4AAAQIECBAgQIAAAQIECBAgIMByBwgQIECAAAECBAgQIECAAAECBFotIMBq9fEYjgABAgQIECBAgAABAgQIECBAQIDlDhAgQIAAAQIECBAgQIAAAQIECLRaQIDV6uMxHAECBAgQIECAAAECBAgQIECAgADLHSBAgAABAgQIECBAgAABAgQIEGi1gACr1cdjOAIECBAgQIAAAQIECBAgQIAAAQGWO0CAAAECBAgQIECAAAECBAgQINBqAQFWq4/HcAQIECBAgAABAgQIECBAgAABAgIsd4AAAQIECBAgQIAAAQIECBAgQKDVAgKsVh+P4QgQIECAAAECBAgQIECAAAECBARY7gABAgQIECBAgAABAgQIECBAgECrBQRYrT4ewxEgQIAAAQIECBAgQIAAAQIECAiw3AECBAgQIECAAAECBAgQIECAAIFWCwiwWn08hiNAgAABAgQIECBAgAABAgQIEBBguQMECBAgQIAAAQIECBAgQIAAAQKtFhBgtfp4DEeAAAECBAgQIECAAAECBAgQICDAcgcIECBAgAABAgQIECBAgAABAgRaLSDAavXxGI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erjMRwBAgQIECBAgAABAgQIECBAgIAAyx0gQIAAAQIECBAgQIAAAQIECBBotYAAq9XHYzgCBAgQIECAAAECBAgQIECAAAEBljtAgAABAgQIECBAgAABAgQIECDQagEBVquPx3AECBAgQIAAAQIECBAgQIAAAQICLHeAAAECBAgQIECAAAECBAgQIECg1QICrFYfj+EIECBAgAABAgQIECBAgAABAgQEWO4AAQIECBAgQIAAAQIECBAgQIBAqwUEWK0+HsMRIECAAAECBAgQIECAAAECBAgIsNwBAgQIECBAgAABAgQIECBAgACBVgsIsFp9PIYjQIAAAQIECBAgQIAAAQIECBAQYLkDBAgQIECAAAECBAgQIECAAAECrRYQYLX6eAxHgAABAgQIECBAgAABAgQIECAgwHIHCBAgQIAAAQIECBAgQIAAAQIEWi0gwGr18RiOAAECBAgQIECAAAECBAgQIEBAgOUOECBAgAABAgQIECBAgAABAgQItFpAgNXq4zEcAQIECBAgQIAAAQIECBAgQICAAMsdIECAAAECBAgQIECAAAECBAgQaLWAAKvVx2M4AgQIECBAgAABAgQIECBAgAABAZY7QIAAAQIECBAgQIAAAQIECBAg0GoBAVarj8dwBAgQIECAAAECBAgQIECAAAECAix3gAABAgQIECBAgAABAgQIECBAoNUCAqxWH4/hCBAgQIAAAQIECBAgQIAAAQIEBFjuAAECBAgQIECAAAECBAgQIECAQKsFBFitPh7DESBAgAABAgQIECBAgAABAgQICLDcAQIECBAgQIAAAQIECBAgQIAAgVYLCLBafTyGI0CAAAECBAgQIECAAAECBAgQEGC5AwQIECBAgAABAgQIECBAgAABAq0WEGC1+ngMR4AAAQIECBAgQIAAAQIECBAgIMByBwgQIECAAAECBAgQIECAAAECBFotIMBq9fEYjgABAgQIECBAgAABAgQIECBAQIDlDhAgQIAAAQIECBAgQIAAAQIECLRaQIDV6uMxHAECBAgQIECAAAECBAgQIECAgADLHSBAgAABAgQIECBAgAABAgQIEGi1gACr1cdjOAIECBAgQIAAAQIECBAgQIAAAQGWO0CAAAECBAgQIECAAAECBAgQINBqAQFWq4/HcAQIECBAgAABAgQIECBAgAABAgIsd4AAAQIECBAgQIAAAQIECBAgQKDVAgKsVh+P4QgQIECAAAECBAgQIECAAAECBARY7gABAgQIECBAgAABAgQIECBAgECrBQRYrT4ewxEgQIAAAQIECBAgQIAAAQIECAiw3AECBAgQIECAAAECBAgQIECAAIFWCwiwWn08hiNAgAABAgQIECBAgAABAgQIEBBguQMECBAgQIAAAQIECBAgQIAAAQKtFhBgtfp4DEeAAAECBAgQIECAAAECBAgQICDAcgcIECBAgAABAgQIECBAgAABAgRaLSDAavXxGI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECu09gKXeO/9oV+69//bx/tBb7c479EWv7c077I2J/p9PZlyP2x9Hfz3tSxGyO2BORZvP63+f1/ztmI+WjvxdH/yxm19dGdL7x13Qk8mg1UjoSEeu/ViP+0++t//7o63+eIo7ko3+ev5oiXT6KfCildHlErP86lFJcnnI6dGTm639/+Bl7L4+U8u47GDsiQIAAAQIECDQTEGA1c1NFgAABAgQIbJPAjc/Nx1w1vOKmefXIzXLM3DQibhqRbxqRTloPpyJiX0TMb9N4k3xsP1JcHjkORUpfiFH+TErx6ejEp1ePpM8cvv7eT8dSumaSD9SLAAECBAgQINBWAQFWW0/GXAQIECBA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AAIIIIAAAggggAACCCCQjQADrGwcqYIAAggggAACCCCAAAIIIIAAAggg0CUBBlhdgqUsAggggAACCCCAAAIIIIAAAggggEA2AgywsnGkCgIIIIAAAggggAACCCCAAAIIIIBAlwQYYHUJlrIIIIAAAggggAACCCCAAAIIIIAAAtkIMMDKxpEqCCCAAAIIIIAAAggggAACCCCAAAJdEmCA1SVYyiKAAAIIIIAAAggggAACCCCAAAIIZCPAACsbR6oggAACCCCAAAIIIIAAAggggAACCHRJgAFWl2ApiwACCCCAAAIIIIAAAggggAACCCCQjQADrGwcqYIAAggggAACCCCAAAIIIIAAAggg0CUBBlhdgqUsAggggAACCCCAAAIIIIAAAggggEA2AgywsnGkCgIIIIAAAggggAACCCCAAAIIIIBAlwQYYHUJlrIIIIAAAggggAACCCCAAAIIIIAAAtkIMMDKxpEqCCCAAAIIIIAAAggggAACCCCAAAJdEmCA1SVYyiKAAAIIIIAAAggggAACCCCAAAIIZCPAACsbR6oggAACCCCAAAIIIIAAAggggAACCHRJgAFWl2ApiwACCCCAAAIIIIAAAggggAACCCCQjQADrGwcqYIAAggggAACCCCAAAIIIIAAAggg0CUBBlhdgqUsAggggAACCCCAAAIIIIAAAggggEA2AgywsnGkCgIIIIAAAggggAACCCCAAAIIIIBAlwQYYHUJlrIIIIAAAggggAACCCCAAAIIIIAAAtkIMMDKxpEqCCCAAAIIIIAAAggggAACCCCAAAJdEmCA1SVYyiKAAAIIIIAAAggggAACCCCAAAIIZCPAACsbR6oggAACCCCAAAIIIIAAAggggAACCHRJgAFWl2ApiwACCCCAAAIIIIAAAggggAACCCCQjQADrGwcqYIAAggggAACCCCAAAIIIIAAAggg0CUBBlhdgqUsAggggAACCCCAAAIIIIAAAggggEA2AgywsnGkCgIIIIAAAggggAACCCCAAAIIIIBAlwQYYHUJlrIIIIAAAggggAACCCCAAAIIIIAAAtkIMMDKxpEqCCCAAAIIIIAAAggggAACCCCAAAJdEmCA1SVYyiKAAAIIIIAAAggggAACCCCAAAIIZCPAACsbR6oggAACCCCAAAIIIIAAAggggAACCHRJgAFWl2ApiwACCCCA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0oPvP7W367+6+G9j9nwsRXwwRawc6Rf/d8waU7Gt6JUPTpFWIuLrx53Hvlj42sP9Ax8624HH/YrtBBG3w6mrI2L7hfaHU8RVg4gjKcdnI8W/5ZzfWX20eE/8XtqaYA9jl26h59hnOWXjX5f94luHLbZ0qLwkp7Q27PppXreQN297ZO28T0zzGfROgACBtgkIsNo2Ef0QIEBgLgVy6vbKB0YsPCByvn1Eul1E3C5S3DKn+GTKcUFEviIifTxy/Efe/t8Lg8sXB+f89eG1m//nXJLtwaEPXLxxp8XF/JAc8dAc8dUpx8HtbxxGxOL17WyHDFVOcVXKcVXO8cGUBn+0tbXvL45e1jm8By17JAECBAgQIECAwIwICLBmZJCOQYAAAQIE9k4gp1iJNItf29s7U08mQIAAAQIECBA4WUCA5T4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgM1bP8gAAGlFJREFUQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQECA5Q4QIECAAAECBAgQIECAAAECBAi0WkCA1erxaI4AAQIECBAgQIAAAQIECBAgQOD/ByjwI0NXLlIaAAAAAElFTkSuQmCC", "type": "binary"}, {"name": "SOM_Web_vert_LG.png", "content": "iVBORw0KGgoAAAANSUhEUgAAA4QAAAGxCAYAAAA6ZngMAAAEFGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDUwLCAyMDE5LzEwLzAxLTE4OjAzOjE2ICAgICAgICAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6ZGFtPSJodHRwOi8vd3d3LmRheS5jb20vZGFtLzEuMCIKICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICBkYW06UGh5c2ljYWxoZWlnaHRpbmluY2hlcz0iMS40NDMzMzYyNDgzOTc4MjcxIgogICBkYW06UGh5c2ljYWx3aWR0aGluaW5jaGVzPSIzLjAwMDAwNTk2MDQ2NDQ3NzUiCiAgIGRhbTpGaWxlZm9ybWF0PSJQTkciCiAgIGRhbTpQcm9ncmVzc2l2ZT0ibm8iCiAgIGRhbTpleHRyYWN0ZWQ9IjIwMjItMDctMTFUMTc6MDA6MDguNTg3LTA3OjAwIgogICBkYW06Qml0c3BlcnBpeGVsPSIzMiIKICAgZGFtOk1JTUV0eXBlPSJpbWFnZS9wbmciCiAgIGRhbTpQaHlzaWNhbHdpZHRoaW5kcGk9IjMwMCIKICAgZGFtOlBoeXNpY2FsaGVpZ2h0aW5kcGk9IjMwMCIKICAgZGFtOk51bWJlcm9maW1hZ2VzPSIxIgogICBkYW06TnVtYmVyb2Z0ZXh0dWFsY29tbWVudHM9IjAiCiAgIGRhbTpzaGExPSI1NWEwMDIxYTg2MTU3MmQzOTNlMWIyZWVjZDNkOTliNzMxZDc1YjJhIgogICBk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", "type": "binary"}, {"name": "utils.py", "content": "import collections\nimport pandas as pd\nimport regex as re\nfrom Bio.Seq import MutableSeq\nfrom Bio.SeqUtils import MeltingTemp as mt\nfrom math import log\nfrom itertools import product, combinations \nimport numpy as np\nimport subprocess, os\nimport numpy as np\nfrom calculate_scores import calculate_on_target_scores, calculate_off_target_scores \n\n\nbases = {\"A\", \"C\", \"G\", \"T\"}\n\nedit_start = 4\nedit_end = 9\ngRNA_size = 20\npam_length = None\nPAMs = None\nreverse_PAMs = None\n\n#helper function to find be guide rnas, pams, and 30 nt sequence\ndef find_BE_guide_rnas(direction, seq, genomic_location):\n    if direction == \"forward\":\n        start_pams = genomic_location + (gRNA_size - edit_end) + 1\n        end_pams = genomic_location + (gRNA_size - edit_start) + pam_length + 1\n        possible_pams = seq[start_pams : end_pams]\n        if len(re.findall(PAMs, str(possible_pams))) == 0:\n            return \"NO PAM\"\n        else:\n            guideRNAs = []\n            pams = []\n            azimuth_sequences = []\n            for match in re.finditer(PAMs, str(possible_pams), overlapped=True):\n                gRNA = seq[start_pams + match.start() - gRNA_size: start_pams + match.start()]\n                pam = possible_pams[match.start(): match.start() + pam_length]\n                guideRNAs.append(str(gRNA))\n                pams.append(str(pam))\n                start_idx = start_pams + match.start() - gRNA_size - 4\n                end_idx = start_pams + match.start() + pam_length + 3\n                azimuth_sequence = seq[start_idx:end_idx]\n                azimuth_sequences.append(str(azimuth_sequence))\n                \n               \n                \n            #azimuth_sequences = update_azimuth_sequences(azimuth_sequences, pam_length)\n            return guideRNAs, pams, azimuth_sequences\n\n    elif direction == \"reverse\":\n        start_pams = genomic_location - gRNA_size + edit_start - pam_length\n        end_pams = genomic_location - gRNA_size + edit_end\n        possible_pams = seq[start_pams : end_pams]\n        if len(re.findall(reverse_PAMs, str(possible_pams))) == 0:\n            return \"NO PAM\"\n        else:\n            guideRNAs = []\n            pams = []\n            azimuth_sequences = []\n            for match in re.finditer(reverse_PAMs, str(possible_pams), overlapped=True):\n                gRNA_start = start_pams + match.start() + pam_length\n                gRNA_end = gRNA_start + gRNA_size\n                gRNA = seq[gRNA_start : gRNA_end]\n                pam = possible_pams[match.start(): match.start() + pam_length]\n                guideRNAs.append(str(gRNA.reverse_complement()))\n                pams.append(str(pam.reverse_complement()))  # Correct the PAM to be the reverse complement\n                start_idx = start_pams + match.start() - 3\n                end_idx = start_pams + match.start() + gRNA_size + pam_length + 4\n                azimuth_sequence = seq[start_idx:end_idx].reverse_complement()\n                azimuth_sequences.append(str(azimuth_sequence))\n                \n            #azimuth_sequences = update_azimuth_sequences(azimuth_sequences, pam_length)\n            return guideRNAs, pams, azimuth_sequences\n    else:\n        return \"ERROR\"\n\n# dictionary for guide rna cloning plasmid\npam_to_url = {\n    \"NNNRRT_NNGRRT_NNGRR\": (70709,  \"https://www.addgene.org/70709\"),\n    \"NGG_NGN_NRN_NYN_NGA\": (140580, \"https://www.addgene.org/140580\")\n}\n\ndef get_cloning_url(pam):\n    pam_patterns = {\n        \"NNNRRT\": \"NNNRRT_NNGRRT_NNGRR\",\n        \"NNGRRT\": \"NNNRRT_NNGRRT_NNGRR\",\n        \"NNGRR\": \"NNNRRT_NNGRRT_NNGRR\",\n        \"NGG\": \"NGG_NGN_NRN_NYN_NGA\",\n        \"NGN\": \"NGG_NGN_NRN_NYN_NGA\",\n        \"NRN\": \"NGG_NGN_NRN_NYN_NGA\",\n        \"NYN\": \"NGG_NGN_NRN_NYN_NGA\",\n        \"NGA\": \"NGG_NGN_NRN_NYN_NGA\"\n    }\n    \n    cloning_group = pam_patterns.get(pam)\n    url = pam_to_url.get(cloning_group)\n    \n    return url\n \n#helper function to track position of base to edit within the guide rna and then return potential bystander edits   \ndef track_positions(guide, ref_sequence_input, substitution_position, orientation):\n    ref_sequence_almost_rc = almost_reverse_complement(ref_sequence_input)\n    base_to_edit = ref_sequence_input[substitution_position] if orientation != 'reverse' else ref_sequence_almost_rc[substitution_position]\n    \n    if orientation == 'reverse':\n        guide = guide[::-1]\n        all_guide_occurance_starts = [m.start() for m in re.finditer(guide, ref_sequence_almost_rc)]\n    else:\n        all_guide_occurance_starts = [m.start() for m in re.finditer(guide, ref_sequence_input)]\n\n    true_starting_positions = []\n    for start in all_guide_occurance_starts:\n        end = start + len(guide) - 1\n        if substitution_position >= start and substitution_position <= end:\n            true_starting_positions.append(start)\n    \n    assert len(true_starting_positions) == 1, (\"Error! Guide cannot be aligned properly to input original sequence\", guide, ref_sequence_almost_rc, orientation, all_guide_occurance_starts, substitution_position)\n    guide_start = true_starting_positions[0]\n\n    if orientation == 'reverse':\n        window_sequence = ref_sequence_almost_rc[guide_start + len(guide) - edit_end: guide_start + len(guide) - edit_start + 1][::-1]\n        actual_base_position = guide_start + len(guide) - substitution_position \n    else:\n        window_sequence = ref_sequence_input[guide_start + edit_start - 1: guide_start + edit_end]\n        actual_base_position = substitution_position - guide_start + 1   # Adjust to 0-based index for the window\n\n    all_positions = [i for i, base in enumerate(window_sequence, start=edit_start) if base == base_to_edit]\n    \n    if actual_base_position in all_positions:\n        all_positions.remove(actual_base_position)\n\n    if len(all_positions) > 0:\n        return f\"Yes (positions: {', '.join(map(str, all_positions))})\"\n    else:\n        return \"No\"\n\n\n\n#helper function for experimental validation of base editing guide rnas\ndef process_guide_rnas(guide_rnas):\n    results = []\n    for guide_rna in guide_rnas:\n        # Replace the first letter with G\n        modified_guide_rna = 'G' + guide_rna[1:]\n        \n        # Generate the reverse complement\n        reverse_guide = str(reverse_complement(modified_guide_rna))\n        \n        # Replace the last letter of the reverse complement with C\n        reverse_complement_modified = reverse_guide[:-1] + 'C'\n        \n        # Format the output\n        result = f\"5' - CACC {modified_guide_rna} - 3'\\n5' - AAAC {reverse_complement_modified} - 3'\"\n        results.append(result)\n    \n    return results\n\n\ndef generate_mutations_to_single_base(guide_rnas, max_mutations=3):\n    bases = {'A', 'C', 'G', 'T'}\n    all_mutated_guides = []\n\n    def mutate_single_position(guide, position, new_base):\n        new_guide = guide[:]\n        new_guide[position] = new_base\n        return ''.join(new_guide)\n\n    for guide_rna in guide_rnas:\n        guide_rna_list = list(guide_rna)\n        for target_base in bases:\n            mutated_guides = []\n            for num_mutations in range(1, max_mutations + 1):\n                for positions in combinations(range(len(guide_rna)), num_mutations):\n                    new_guide = guide_rna_list[:]\n                    for pos in positions:\n                        new_guide[pos] = target_base\n                    mutated_guides.append(''.join(new_guide))\n            all_mutated_guides.extend(mutated_guides)\n\n    return all_mutated_guides\n\ndef calculate_off_target_scores_for_guides(guide_rnas, pams):\n    all_results = []\n\n    for guide_rna, pam in zip(guide_rnas, pams):\n        protospacers = generate_mutations_to_single_base([guide_rna])\n        scores_df = calculate_off_target_scores([guide_rna] * len(protospacers), protospacers, [pam] * len(protospacers))\n        scores_df['guide_rna'] = guide_rna\n        all_results.append(scores_df)\n    \n    combined_scores = pd.concat(all_results)\n\n    # this is to ensure only numeric columns are averaged\n    numeric_columns = combined_scores.select_dtypes(include=[np.number]).columns.tolist()\n    numeric_columns.append('guide_rna')\n\n    average_scores = combined_scores[numeric_columns].groupby('guide_rna').mean().reset_index()\n    average_scores['score'] = 100-(average_scores['score'].round(3)*100)\n\n    return combined_scores, average_scores\n\n\n#Define editor data, dictionary for type of editing enzymes\neditor_data = {\n    'ABE': {\n        'NGN': ('ABE8e-NG enzyme', '138491', 'https://www.addgene.org/138491'),\n        'NGG': ('ABE8e enzyme', '138489', 'https://www.addgene.org/138489'),\n        'NGA': ('ABE8e-NG enzyme', '138491', 'https://www.addgene.org/138491'),\n        'NNGRRT': ('ABE8e-SaCas enzyme', '138500', 'https://www.addgene.org/138500'),\n        'NNNRRT': ('ABE8e-SaCas-KKH enzyme', '138502', 'https://www.addgene.org/138502'),\n        'NRN': ('SpRY', '140003', 'https://www.addgene.org/140003/')\n    },\n    'CBE': {\n        'NGN': ('BE4max-NG', '138159', 'https://www.addgene.org/138159'),\n        'NGG': ('BE4max', '112093', 'https://www.addgene.org/112093'),\n        'NGA': ('BE4max-NG', '138159', 'https://www.addgene.org/138159'),\n        'NNGRRT': ('BE3-SaCas', '85169', 'https://www.addgene.org/85169'),\n        'NNNRRT': ('BE3-SaCas-KKH', '85170', 'https://www.addgene.org/85170'),\n        'NRN' : ('SpRY', '139999', 'https://www.addgene.org/139999/')\n    },\n    'transversion': {\n        'NGN' : ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/' ),\n        'NGG': ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/' ),\n        'NGA': ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/'),\n        'NNGRRT': ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/'),\n        'NNNRRT': ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/'),\n        'NRN' : ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/')\n    },\n    'PrimeEditor': {\n    'default': ('PE6D', '207854', 'https://www.addgene.org/207854/')\n    },\n}    \n\n#determine the mutation type for the base editors\ndef determine_mutation_type(ref_seq, edited_seq, pams=None):\n    mutation_type = \"PrimeEditor\"  # Default mutation type is PrimeEditor\n    for ref_base, edit_base in zip(ref_seq, edited_seq):\n        if ref_base != edit_base:\n            # Create a mutation identifier from reference and edited bases\n            edit_type = f\"{ref_base}>{edit_base}\"\n            \n            # Determine the type of base editing required based on the mutation\n            if edit_type in [\"A>G\", \"T>C\"]:\n                return \"ABE\"\n            elif edit_type in [\"G>A\", \"C>T\"]:\n                return \"CBE\"\n            elif edit_type in [\"C>G\", \"G>C\"]:\n                return \"transversion\"   \n    return mutation_type \n\n\n\n# Helper function to find guide RNAs for transversion (C>G and G>C) mutations on forward/reverse strands\ndef find_trans_guide_rnas(direction, seq, genomic_location):\n    if direction == \"forward\":\n        pam = seq[genomic_location + 15 : genomic_location + 15 + pam_length]\n        if len(re.findall(PAMs, str(pam))) == 0:\n            return \"NO PAM\"\n        else:\n            return seq[genomic_location + 15 - gRNA_size : genomic_location + 15]\n    elif direction == \"reverse\":\n        pam = seq[genomic_location - 15 - 1: genomic_location - 15 - 1 + pam_length]\n        if len(re.findall(reverse_PAMs, str(pam))) == 0:\n            return \"NO PAM\"\n        else:\n            gRNA = seq[genomic_location - 15 - 1 + pam_length: genomic_location - 15 - 1 + pam_length + gRNA_size]\n            gRNA.reverse_complement(inplace=True)\n            return gRNA\n    else:\n        return \"ERROR\"\n\n\n# Adds the base editable guide RNAs to the data table for export\ndef get_guide_RNAs(mutant_seq, edit_type, genomic_location):\n    try:\n        if edit_type == \"A>G\":\n            result = find_BE_guide_rnas(\"forward\", mutant_seq, genomic_location)\n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"forward\"\n        elif edit_type == \"T>C\":\n            result = find_BE_guide_rnas(\"reverse\", mutant_seq, genomic_location)\n      \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"reverse\"\n        elif edit_type == \"G>A\":\n            result = find_BE_guide_rnas(\"reverse\", mutant_seq, genomic_location)\n           \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"reverse\"\n        elif edit_type == \"C>T\":\n            result = find_BE_guide_rnas(\"forward\", mutant_seq, genomic_location)\n           \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"forward\"\n        elif edit_type == \"G>C\":\n            result = find_trans_guide_rnas(\"forward\", mutant_seq, genomic_location)\n           \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"forward\"\n        elif edit_type == \"C>G\":\n            result = find_trans_guide_rnas(\"reverse\", mutant_seq, genomic_location)\n           \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"reverse\"\n        else:\n            return ((\"NOT BASE EDITABLE\", None, None), None)\n    \n    except Exception as e:\n        print(f\"Exception in get_guide_RNAs: {e}\")\n        return ((\"ERROR\", None, None), None)\n\n\n#helper function to set pam sequences: Initialize PAM sequences based on the provided PAM\ndef set_pam_sequences(PAM):\n    global PAMs, reverse_PAMs, pam_length\n    pam_length = len(PAM)\n    if PAM == 'NGN':\n        PAMs = re.compile(\"[A|T|G|C]G[A|T|G|C]\")\n        reverse_PAMs = re.compile(\"[A|T|G|C]C[A|T|G|C]\")\n    elif PAM == 'NGG':\n        PAMs = re.compile(\"[A|T|G|C]GG\")\n        reverse_PAMs = re.compile(\"CC[A|T|G|C]\")\n    elif PAM == 'NGA':\n        PAMs = re.compile(\"[A|T|G|C]GA\")\n        reverse_PAMs = re.compile(\"TC[A|T|G|C]\")\n    elif PAM == 'NNGRRT':\n        PAMs = re.compile(\"[A|T|G|C][A|T|G|C]G[A|G][A|G]T\")\n        reverse_PAMs = re.compile(\"A[T|C][T|C]C[A|T|G|C][A|T|G|C]\")\n    elif PAM == 'NNNRRT':\n        PAMs = re.compile(\"[A|T|G|C][A|T|G|C][A|T|G|C][A|G][A|G]T\")\n        reverse_PAMs = re.compile(\"A[T|C][T|C][A|T|G|C][A|T|G|C][A|T|G|C]\")\n    elif PAM == 'NRN':\n        PAMs = re.compile(\"[A|T|G|C][G|A][A|T|G|C]\")\n        reverse_PAMs = re.compile(\"[A|T|G|C][C|T][A|T|G|C]\")   \n    elif PAM == 'NYN':\n        PAMs = re.compile(\"[A|T|G|C][C|T][A|T|G|C]\")\n        reverse_PAMs = re.compile(\"[A|T|G|C][G|A][A|T|G|C]\")   \n    else:\n        raise ValueError(\"Invalid PAM sequence\")\n \n #helper function to create mutuable seq: Convert input sequences to mutable sequences  \ndef create_mutable_sequences(ref_sequence_original, edited_sequence_original):\n    ref_sequence = MutableSeq(ref_sequence_original)\n    edited_sequence = MutableSeq(edited_sequence_original)\n    return ref_sequence, edited_sequence\n\n#helper function to identify substitution position: Find the position of the substitution in the sequences\ndef identify_substitution_position(ref_sequence, edited_sequence):\n    substitution_position = None\n    for i in range(len(ref_sequence)):\n        ref_base = ref_sequence[i]\n        edited_base = edited_sequence[i]\n        if ref_base != edited_base:\n            substitution_position = i\n            break\n    return substitution_position\n\n#helper function to determine the appropriate guide RNAs based on the mutation type.\ndef get_guide_rnas_and_orientation(ref_sequence, edit, substitution_position):\n    try:\n        result = get_guide_RNAs(ref_sequence, edit, substitution_position)\n\n        if result is None or result[0] is None:\n            raise ValueError(\"Invalid result from get_guide_RNAs\")\n        \n        (guide_rnas, pams, azimuth_sequences), orientation = result\n        \n        return guide_rnas, orientation, pams, azimuth_sequences\n    \n    except ValueError as ve:\n        print(f\"ValueError: {ve}\")\n        print(f\"result: {result}\")\n    except Exception as e:\n        print(f\"Exception: {e}\")\n        print(f\"result: {result}\")\n\n\n#helper function to generate prime design outputs if necessary\ndef run_prime_design(ref_sequence, edited_sequence, substitution_position):\n    primedesign_input = str(ref_sequence[:substitution_position] + f\"({ref_sequence[substitution_position]}/{edited_sequence[substitution_position]})\" + ref_sequence[substitution_position + 1:])\n    primedesign_output = run_primedesign(str(primedesign_input))\n    return primedesign_output\n\n#helper function to handle deletions: process cases where there are insertions.\ndef handle_insertions(ref_sequence, edited_sequence, df_dict, ref_sequence_original, edited_sequence_original):\n    insertion_start = ref_sequence.find('-')\n    insertion_end = ref_sequence.rfind('-')\n    if insertion_end - insertion_start + 1 > 44:\n        add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"Use Twin Prime Editing/Integrase/HDR\")\n    else:\n        primedesign_input = str(ref_sequence[:insertion_start] + f\"(+{edited_sequence[insertion_start : insertion_end + 1]})\" + ref_sequence[insertion_end + 1:])\n        primedesign_output = run_primedesign(primedesign_input)\n        if primedesign_output != \"No PrimeDesign Recommended Guides\":\n            update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, \"Prime Editing\")\n        else:\n            add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"Use Twin Prime Editing/Integrase/HDR\")\n    return df_dict\n\n\n#helper function to handle deletions: process cases where there are deletions.\ndef handle_deletions(ref_sequence, edited_sequence, df_dict, ref_sequence_original, edited_sequence_original):\n    deletion_start = edited_sequence.find('-')\n    deletion_end = edited_sequence.rfind('-')\n    if deletion_start - deletion_end + 1 > 80:\n        add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"Use Twin Prime Editing/Integrase/HDR\")\n    else:\n        primedesign_input = str(ref_sequence[:deletion_start] + f\"(-{ref_sequence[deletion_start : deletion_end + 1]})\" + ref_sequence[deletion_end + 1:])\n        primedesign_output = run_primedesign(primedesign_input)\n        if primedesign_output != \"No PrimeDesign Recommended Guides\":\n            update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, \"Prime Editing\")\n        else:\n            add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"Use Twin Prime Editing/Integrase/HDR\")\n    return df_dict\n\n#helper function to add insertions and deletions\ndef add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, editing_technology):\n    df_dict['Original Sequence'].append(ref_sequence_original)\n    df_dict['Desired Sequence'].append(edited_sequence_original)\n    df_dict['Editing Technology'].append(editing_technology)\n    df_dict['Base Editing Guide'].append(None)\n    df_dict['Off Target Score'].append(None)\n    df_dict['On Target Score'].append(None)\n    df_dict['Bystander Edits?'].append(None)\n    df_dict['PrimeDesign pegRNA Annotation'].append(None)\n    df_dict['PrimeDesign pegRNA PBS'].append(None)\n    df_dict['PrimeDesign pegRNA RTT'].append(None)\n    df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n    df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n    df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n    df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n    df_dict['PrimeDesign ngRNA Annotation'].append(None)\n    df_dict['PrimeDesign ngRNA Distance'].append(None)\n    df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n    df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n\n#helper function to update the dataframe dictionary with prime design output\ndef update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, editing_technology):\n    peg_spacer_top_recommended, peg_spacer_bottom_recommended, peg_ext_top_recommended, peg_ext_bottom_recommended, peg_annotation_recommended, peg_pbs_recommended, peg_rtt_recommended, ng_spacer_top_recommended, ng_spacer_bottom_recommended, ng_annotation_recommended, ng_distance_recommended = primedesign_output\n    df_dict['Original Sequence'].append(ref_sequence_original)\n    df_dict['Desired Sequence'].append(edited_sequence_original)\n    df_dict['Editing Technology'].append(editing_technology)\n    df_dict['Base Editing Guide'].append(None)\n    df_dict['Off Target Score (Click To Toggle)'].append(None)\n    df_dict['On Target Score (Click To Toggle)'].append(None)\n    df_dict['Bystander Edits?'].append(None)\n    df_dict['PrimeDesign pegRNA Annotation'].append(peg_annotation_recommended)\n    df_dict['PrimeDesign pegRNA PBS'].append(peg_pbs_recommended)\n    df_dict['PrimeDesign pegRNA RTT'].append(peg_rtt_recommended)\n    df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(peg_spacer_top_recommended)\n    df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(peg_spacer_bottom_recommended)\n    df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(peg_ext_top_recommended)\n    df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(peg_ext_bottom_recommended)\n    df_dict['PrimeDesign ngRNA Annotation'].append(ng_annotation_recommended)\n    df_dict['PrimeDesign ngRNA Distance'].append(ng_distance_recommended)\n    df_dict['PrimeDesign ngRNA Oligo Top'].append(ng_spacer_top_recommended)\n    df_dict['PrimeDesign ngRNA Bottom Top'].append(ng_spacer_bottom_recommended)\n\n#helper function prepare the data for output as a dataframe\ndef render_dataframe(df_dict):\n    df_dict_render = collections.defaultdict(list)\n    max_length = max(len(v) for v in df_dict.values())\n    for key in df_dict:\n        while len(df_dict[key]) < max_length:\n            df_dict[key].append(None)\n        df_dict_render[key] = df_dict[key]\n    df_render = pd.DataFrame.from_dict(df_dict_render).dropna(how='all', axis=1)\n    df_full = pd.DataFrame.from_dict(df_dict).dropna(how='all', axis=1)\n    if 'Base Editing Guide' in df_render.columns:\n         df_render = df_render[df_render['Base Editing Guide'].notna()]\n        df_render = df_render[df_render['Base Editing Guide'] != '']\n    return df_render, df_full\n\n\n\ndef get_guides(ref_sequence_original, edited_sequence_original, PAM):\n    set_pam_sequences(PAM)\n    ref_sequence, edited_sequence = create_mutable_sequences(ref_sequence_original, edited_sequence_original)\n    df_dict = collections.defaultdict(list)\n\n    if len(set(ref_sequence) - bases) == 0:\n        substitution_position = identify_substitution_position(ref_sequence, edited_sequence)\n        edit = f\"{ref_sequence[substitution_position]}>{edited_sequence[substitution_position]}\"\n        guide_rnas, orientation, pams, azimuth_sequences = get_guide_rnas_and_orientation(ref_sequence, edit, substitution_position)\n        protospacers = generate_mutations_to_single_base(guide_rnas)\n\n        if guide_rnas == \"NOT BASE EDITABLE\":\n            primedesign_output = run_prime_design(ref_sequence, edited_sequence, substitution_position)\n            if primedesign_output != \"No PrimeDesign Recommended Guides\":\n                update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, \"Prime Editing\")\n            else:\n                add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"No Base or Prime Editing Guides Found\")\n        elif guide_rnas == \"NO PAM\":\n            # Rerun gRNA finder for base editing with NRN PAM\n            set_pam_sequences('NRN')\n            guide_rnas, orientation, pams, azimuth_sequences = get_guide_rnas_and_orientation(ref_sequence, edit, substitution_position)\n            if guide_rnas == \"NO PAM\":\n                # Rerun gRNA finder for base editing with NYN PAM\n                set_pam_sequences('NYN')\n                guide_rnas, orientation, pams, azimuth_sequences = get_guide_rnas_and_orientation(ref_sequence, edit, substitution_position)\n                if guide_rnas == \"NO PAM\":\n                    primedesign_output = run_prime_design(ref_sequence, edited_sequence, substitution_position)\n                    if primedesign_output != \"No PrimeDesign Recommended Guides\":\n                        update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, \"Prime Editing\")\n                    else:\n                        add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"No Base or Prime Editing Guides Found\")\n                else:\n                    \n                    #calculate off target score\n                    protospacers = generate_mutations_to_single_base(guide_rnas)\n                    if pams == set_pam_sequences(\"NGG\"):\n                        combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, pams)\n                    else:\n                        try:\n                            combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, [\"CGG\"]*len(guide_rnas))\n                            \n                        \n                        except:\n                            print(f\"Error in calculate_off_target_scores: {e}\")\n                            print(f\"Length of spacers: {len(guide_rnas*len(protospacers))}\")\n                            print(f\"Length of protospacers: {len(protospacers)}\")\n\n                            print(f\"Guide RNAs: {guide_rnas}\")\n                            cfd_scores = {'score': [None] * len(guide_rnas)} \n                            \n                 \n                    # Calculate on-target scores\n                    on_target_scores_df = calculate_on_target_scores(azimuth_sequences)\n                    \n                    # Print NYN PAM gRNAs\n                    if not isinstance(guide_rnas, list):\n                        guide_rnas = [guide_rnas]\n                    for gRNA, cfd_score, on_score in zip(guide_rnas, average_scores['score'],on_target_scores_df['score'] ):\n                        position_info = track_positions(gRNA, ref_sequence_original, substitution_position, orientation)\n                        \n                        df_dict['Original Sequence'].append(ref_sequence_original)\n                        df_dict['Desired Sequence'].append(edited_sequence_original)\n                        df_dict['Editing Technology'].append(\"Base Editing\") #with NYN PAM\n                        df_dict['Base Editing Guide'].append(str(gRNA))\n                        df_dict['Base Editing Guide Orientation'].append(orientation)\n                        df_dict['Off Target Score (Click To Toggle)'].append(cfd_score)\n                        df_dict['On Target Score (Click To Toggle)'].append(on_score)\n                        df_dict['Bystander Edits?'].append(position_info)\n                        df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                        df_dict['PrimeDesign pegRNA PBS'].append(None)\n                        df_dict['PrimeDesign pegRNA RTT'].append(None)\n                        df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                        df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                        df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                        df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                        df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                        df_dict['PrimeDesign ngRNA Distance'].append(None)\n                        df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                        df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n            else:   \n                #calculate off target score\n                \n                protospacers = generate_mutations_to_single_base(guide_rnas)\n                if pams == set_pam_sequences(\"NGG\"):\n                    combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, pams)\n\n                else:\n                    try:\n                        combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, [\"CGG\"]*len(guide_rnas))\n                        \n                        \n                    except Exception as e:\n                        print(f\"Error in calculate_off_target_scores: {e}\")\n                        print(f\"Length of spacers: {len(guide_rnas*len(protospacers))}\")\n                        print(f\"Length of protospacers: {len(protospacers)}\")\n\n                        print(f\"Guide RNAs: {guide_rnas}\")\n                        cfd_scores = {'score': [None] * len(guide_rnas)} \n                \n               \n                # Calculate on-target scores\n                on_target_scores_df = calculate_on_target_scores(azimuth_sequences)\n                # Print NRN PAM gRNAs\n                if not isinstance(guide_rnas, list):\n                    guide_rnas = [guide_rnas]\n                for gRNA, cfd_score, on_score in zip(guide_rnas, average_scores['score'],on_target_scores_df['score'] ):\n                    position_info = track_positions(gRNA, ref_sequence_original, substitution_position, orientation)\n                    \n                    df_dict['Original Sequence'].append(ref_sequence_original)\n                    df_dict['Desired Sequence'].append(edited_sequence_original)\n                    df_dict['Editing Technology'].append(\"Base Editing\") #with nrn pam\n                    df_dict['Base Editing Guide'].append(str(gRNA))\n                    df_dict['Base Editing Guide Orientation'].append(orientation)\n                    df_dict['Base Editing Guide Orientation'].append(orientation)\n                    df_dict['Off Target Score (Click To Toggle)'].append(cfd_score)\n                    df_dict['On Target Score (Click To Toggle)'].append(on_score)\n                    df_dict['Bystander Edits?'].append(position_info)\n                    df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                    df_dict['PrimeDesign pegRNA PBS'].append(None)\n                    df_dict['PrimeDesign pegRNA RTT'].append(None)\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                    df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                    df_dict['PrimeDesign ngRNA Distance'].append(None)\n                    df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                    df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n        else:\n            \n            #calculate off target score\n            protospacers = generate_mutations_to_single_base(guide_rnas)\n            if pams == set_pam_sequences(\"NGG\"):\n                combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, pams)\n               \n            else:    \n                try:\n                    combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, [\"CGG\"]*len(guide_rnas))\n                    \n                   \n                except Exception as e:\n                    print(f\"Error in calculate_off_target_scores: {e}\")\n                    print(f\"Length of spacers: {len(guide_rnas*len(protospacers))}\")\n                    print(f\"Length of protospacers: {len(protospacers)}\")\n\n                    print(f\"Guide RNAs: {guide_rnas}\")\n                    cfd_scores = {'score': [None] * len(guide_rnas)} \n            \n            \n            # Calculate on-target scores\n            on_target_scores_df = calculate_on_target_scores(azimuth_sequences)\n            \n            # Print original PAM gRNAs\n            if not isinstance(guide_rnas, list):\n                guide_rnas = [guide_rnas]\n            for gRNA, cfd_score, on_score in zip(guide_rnas, average_scores['score'],on_target_scores_df['score'] ):\n                position_info = track_positions(gRNA, ref_sequence_original, substitution_position, orientation)\n                \n                df_dict['Original Sequence'].append(ref_sequence_original)\n                df_dict['Desired Sequence'].append(edited_sequence_original)\n                df_dict['Editing Technology'].append(\"Base Editing\")\n                df_dict['Base Editing Guide'].append(str(gRNA))\n                df_dict['Base Editing Guide Orientation'].append(orientation)\n                df_dict['Off Target Score (Click To Toggle)'].append(cfd_score)\n                df_dict['On Target Score (Click To Toggle)'].append(on_score)\n                df_dict['Bystander Edits?'].append(position_info)\n                df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                df_dict['PrimeDesign pegRNA PBS'].append(None)\n                df_dict['PrimeDesign pegRNA RTT'].append(None)\n                df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                df_dict['PrimeDesign ngRNA Distance'].append(None)\n                df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n\n    elif '-' in ref_sequence:\n        df_dict = handle_insertions(ref_sequence, edited_sequence, df_dict, ref_sequence_original, edited_sequence_original)\n        \n    elif '-' in edited_sequence:\n        df_dict = handle_deletions(ref_sequence, edited_sequence, df_dict, ref_sequence_original, edited_sequence_original)\n\n    return render_dataframe(df_dict) \n\n# Helper functions\ndef gc_content(sequence):\n    sequence = sequence.upper()\n    GC_count = sequence.count('G') + sequence.count('C')\n    GC_content = float(GC_count)/float(len(sequence))\n\n    return(\"%.2f\" % GC_content)\n\n# IUPAC code map\niupac2bases_dict = {'A':'A','T':'T','C':'C','G':'G','a':'a','t':'t','c':'c','g':'g',\n'R':'[AG]','Y':'[CT]','S':'[GC]','W':'[AT]','K':'[GT]','M':'[AC]','B':'[CGT]','D':'[AGT]','H':'[ACT]','V':'[ACG]','N':'[ACTG]',\n'r':'[ag]','y':'[ct]','s':'[gc]','w':'[at]','k':'[gt]','m':'[ac]','b':'[cgt]','d':'[agt]','h':'[act]','v':'[acg]','n':'[actg]',\n'(':'(',')':')','+':'+','-':'-','/':'/'}\n\ndef iupac2bases(iupac):\n\n    try:\n        bases = iupac2bases_dict[iupac]\n    except:\n        logger.error('Symbol %s is not within the IUPAC nucleotide code ...' % str(iupac))\n        sys.exit(1)\n\n    return(bases)\n\n# Reverse complement function\ndef reverse_complement(sequence):\n    sequence = sequence\n    new_sequence = ''\n    for base in sequence:\n        if base == 'A':\n            new_sequence += 'T'\n        elif base == 'T':\n            new_sequence += 'A'\n        elif base == 'C':\n            new_sequence += 'G'\n        elif base == 'G':\n            new_sequence += 'C'\n        elif base == 'a':\n            new_sequence += 't'\n        elif base == 't':\n            new_sequence += 'a'\n        elif base == 'c':\n            new_sequence += 'g'\n        elif base == 'g':\n            new_sequence += 'c'\n        elif base == '[':\n            new_sequence += ']'\n        elif base == ']':\n            new_sequence += '['\n        elif base == '+':\n            new_sequence += '+'\n        elif base == '-':\n            new_sequence += '-'\n        elif base == '/':\n            new_sequence += '/'\n        elif base == '(':\n            new_sequence += ')'\n        elif base == ')':\n            new_sequence += '('\n    return(new_sequence[::-1])\n\ndef almost_reverse_complement(sequence):\n    sequence = sequence\n    new_sequence = ''\n    for base in sequence:\n        if base == 'A':\n            new_sequence += 'T'\n        elif base == 'T':\n            new_sequence += 'A'\n        elif base == 'C':\n            new_sequence += 'G'\n        elif base == 'G':\n            new_sequence += 'C'\n        elif base == 'a':\n            new_sequence += 't'\n        elif base == 't':\n            new_sequence += 'a'\n        elif base == 'c':\n            new_sequence += 'g'\n        elif base == 'g':\n            new_sequence += 'c'\n        elif base == '[':\n            new_sequence += ']'\n        elif base == ']':\n            new_sequence += '['\n        elif base == '+':\n            new_sequence += '+'\n        elif base == '-':\n            new_sequence += '-'\n        elif base == '/':\n            new_sequence += '/'\n        elif base == '(':\n            new_sequence += ')'\n        elif base == ')':\n            new_sequence += '('\n    return new_sequence\n\n# Extract reference and edited sequence information\ndef process_sequence(input_sequence):\n\n    input_sequence = ''.join(input_sequence.split())\n\n    # Check formatting is correct\n    format_check = ''\n    for i in input_sequence:\n        if i == '(':\n            format_check += '('\n        elif i == ')':\n            format_check += ')'\n        elif i == '/':\n            format_check += '/'\n        elif i == '+':\n            format_check += '+'\n        elif i == '-':\n            format_check += '-'\n\n    # Check composition of input sequence\n    if len(input_sequence) != sum([1 if x in ['A','T','C','G','(',')','+','-','/'] else 0 for x in input_sequence.upper()]):\n        assert False\n\n    # Check formatting\n    if format_check.count('(') == format_check.count(')') and format_check.count('(') > 0: # Left and right parantheses equal\n        if '((' not in format_check: # Checks both directions for nested parantheses\n            if '()' not in format_check: # Checks for empty annotations\n                if sum([1 if x in format_check else 0 for x in ['++','--','//','+-','+/','-+','-/','/+','/-','/(','+(','-(',')/',')+',')-']]) == 0:\n                    pass\n\n    # Create mapping between input format and reference and edit sequence\n    editformat2sequence = {}\n    edits = re.findall('\\(.*?\\)', input_sequence)\n    for edit in edits:\n        if '/' in edit:\n            editformat2sequence[edit] = [edit.split('/')[0].replace('(',''), edit.split('/')[1].replace(')','')]\n        elif '+' in edit:\n            editformat2sequence[edit] = ['' , edit.split('+')[1].replace(')','')]\n        elif '-' in edit:\n            editformat2sequence[edit] = [edit.split('-')[1].replace(')',''), '']\n\n    # Create mapping between edit number and reference and edit sequence\n    editformat2sequence = {}\n    editnumber2sequence = {}\n    edit_idxs = [[m.start(), m.end()] for m in re.finditer('\\(.*?\\)', input_sequence)]\n    edit_counter = 1\n    for edit_idx in edit_idxs:\n        edit = input_sequence[edit_idx[0]:edit_idx[1]]\n\n        # Create edit format and number to sequence map\n        if '/' in edit:\n            editformat2sequence[edit] = [edit.split('/')[0].replace('(',''), edit.split('/')[1].replace(')','').lower(), edit_counter]\n            editnumber2sequence[edit_counter] = [edit.split('/')[0].replace('(',''), edit.split('/')[1].replace(')','').lower()]\n\n        elif '+' in edit:\n            editformat2sequence[edit] = ['' , edit.split('+')[1].replace(')','').lower(), edit_counter]\n            editnumber2sequence[edit_counter] = ['' , edit.split('+')[1].replace(')','').lower()]\n\n        elif '-' in edit:\n            editformat2sequence[edit] = [edit.split('-')[1].replace(')',''), '', edit_counter]\n            editnumber2sequence[edit_counter] = [edit.split('-')[1].replace(')',''), '']\n\n        edit_counter += 1\n\n    edit_start = min([i.start() for i in re.finditer('\\(', input_sequence)])\n    edit_stop = max([i.start() for i in re.finditer('\\)', input_sequence)])\n\n    edit_span_sequence_w_ref = input_sequence[edit_start:edit_stop + 1]\n    edit_span_sequence_w_edit = input_sequence[edit_start:edit_stop + 1]\n    for edit in editformat2sequence:\n        edit_span_sequence_w_ref = edit_span_sequence_w_ref.replace(edit, editformat2sequence[edit][0])\n        edit_span_sequence_w_edit = edit_span_sequence_w_edit.replace(edit, editformat2sequence[edit][1])\n\n    edit_start_in_ref = re.search('\\(', input_sequence).start()\n    edit_stop_in_ref_rev = re.search('\\)', input_sequence[::-1]).start()\n\n    edit_span_length_w_ref = len(edit_span_sequence_w_ref)\n    edit_span_length_w_edit = len(edit_span_sequence_w_edit)\n\n    reference_sequence = input_sequence\n    edit_sequence = input_sequence\n    editnumber_sequence = input_sequence\n    for edit in editformat2sequence:\n        reference_sequence = reference_sequence.replace(edit, editformat2sequence[edit][0])\n        edit_sequence = edit_sequence.replace(edit, editformat2sequence[edit][1])\n        editnumber_sequence = editnumber_sequence.replace(edit, str(editformat2sequence[edit][2]))\n\n    return(editformat2sequence, editnumber2sequence, reference_sequence, edit_sequence, editnumber_sequence, edit_span_length_w_ref, edit_span_length_w_edit, edit_start_in_ref, edit_stop_in_ref_rev)\n\ndef run_primedesign(input_sequence):\n    target_design = {}\n    peg_design = {'pegRNA group':[],'type':[], 'spacer sequence':[],'spacer GC content':[],'PAM':[],'strand':[],'peg-to-edit distance':[],'nick-to-peg distance':[],'pegRNA extension':[], 'extension first base':[],'PBS length':[],'PBS GC content':[], 'PBS Tm':[], 'RTT length':[],'RTT GC content':[],'annotation':[],'spacer top strand oligo':[], 'spacer bottom strand oligo':[], 'pegRNA extension top strand oligo':[], 'pegRNA extension bottom strand oligo':[], 'CFD score':[]}\n\n    input_sequence = ''.join(input_sequence.split())\n    pe_format = 'NNNNNNNNNNNNNNNNN/NNN[NGG]'\n    \n    pbs_length_list = list(range(12, 15))\n    rtt_length_list = list(range(10, 21))\n\n    if 80 not in rtt_length_list:\n        rtt_length_list.append(80)\n        rtt_length_list = sorted(rtt_length_list)\n\n    nicking_distance_minimum = 0\n    nicking_distance_maximum = 100\n\n    target_sequence = input_sequence\n    target_name = 'user-input'\n\n    target_sequence = target_sequence.upper()\n    editformat2sequence, editnumber2sequence, reference_sequence, edit_sequence, editnumber_sequence, edit_span_length_w_ref, edit_span_length_w_edit, edit_start_in_ref, edit_stop_in_ref_rev = process_sequence(target_sequence)\n\n    # Initialize dictionary for the design of pegRNA spacers for each target sequence and intended edit(s)\n    target_design[target_name] = {'target_sequence':target_sequence, 'editformat2sequence': editformat2sequence, 'editnumber2sequence': editnumber2sequence, 'reference_sequence': reference_sequence, 'edit_sequence': edit_sequence, 'editnumber_sequence': editnumber_sequence, 'edit_span_length': [edit_span_length_w_ref, edit_span_length_w_edit], 'edit_start_in_ref': edit_start_in_ref, 'edit_stop_in_ref_rev': edit_stop_in_ref_rev, 'pegRNA':{'+':[], '-':[]}, 'ngRNA':{'+':[], '-':[]}}\n\n    # Find indices but shift when removing annotations\n    cut_idx = re.search('/', pe_format).start()\n    pam_start_idx = re.search('\\[', pe_format).start()\n    pam_end_idx = re.search('\\]', pe_format).start()\n\n    # Find pam and total PE format search length\n    pam_length = pam_end_idx - pam_start_idx - 1\n    pe_format_length = len(pe_format) - 3\n\n    # Check if cut site is left of PAM\n    if cut_idx < pam_start_idx:\n\n        # Shift indices with removal of annotations\n        pam_start_idx = pam_start_idx - 1\n        pam_end_idx = pam_end_idx - 2\n        spacer_start_idx = 0\n        spacer_end_idx = pam_start_idx\n\n    else:\n        pam_end_idx = pam_end_idx - 1\n        cut_idx = cut_idx - 2\n        spacer_start_idx = pam_end_idx\n        spacer_end_idx = len(pe_format) - 3\n\n    # Remove annotations and convert into regex\n    pe_format_rm_annotation = pe_format.replace('/', '').replace('[', '').replace(']', '')\n\n    # Create PE format and PAM search sequences\n    pe_format_search_plus = ''\n    for base in pe_format_rm_annotation:\n        pe_format_search_plus += iupac2bases(base)\n    pe_format_search_minus = reverse_complement(pe_format_search_plus)\n\n    pam_search = ''\n    pam_sequence = pe_format_rm_annotation[pam_start_idx:pam_end_idx]\n    for base in pam_sequence:\n        pam_search += iupac2bases(base)\n\n    ##### Initialize data storage for output\n    counter = 1\n    for target_name in target_design:\n\n        # pegRNA spacer search for (+) and (-) strands with reference sequence\n        reference_sequence = target_design[target_name]['reference_sequence']\n        find_guides_ref_plus = [[m.start()] for m in re.finditer('(?=%s)' % pe_format_search_plus, reference_sequence, re.IGNORECASE)]\n        find_guides_ref_minus = [[m.start()] for m in re.finditer('(?=%s)' % pe_format_search_minus, reference_sequence, re.IGNORECASE)]\n\n        # pegRNA spacer search for (+) and (-) strands with edit number sequence\n        editnumber_sequence = target_design[target_name]['editnumber_sequence']\n        find_guides_editnumber_plus = [[m.start()] for m in re.finditer('(?=%s)' % pam_search.replace('[', '[123456789'), editnumber_sequence, re.IGNORECASE)]\n        find_guides_editnumber_minus = [[m.start()] for m in re.finditer('(?=%s)' % reverse_complement(pam_search).replace('[', '[123456789'), editnumber_sequence, re.IGNORECASE)]\n\n        # Find pegRNA spacers targeting (+) strand\n        if find_guides_ref_plus:\n\n            for match in find_guides_ref_plus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = reference_sequence[match[0]:match[0] + pe_format_length]\n                spacer_sequence = full_search[spacer_start_idx:spacer_end_idx]\n                extension_core_sequence = full_search[:cut_idx]\n                downstream_sequence_ref = full_search[cut_idx:]\n                downstream_sequence_length = len(downstream_sequence_ref)\n                pam_ref = full_search[pam_start_idx:pam_end_idx]\n\n                # Check to see if the extended non target strand is conserved in the edited strand\n                try:\n                    extension_core_start_idx, extension_core_end_idx = re.search(extension_core_sequence, edit_sequence).start(), re.search(extension_core_sequence, edit_sequence).end()\n                    downstream_sequence_edit = edit_sequence[extension_core_end_idx:extension_core_end_idx + downstream_sequence_length]\n                    pam_edit = edit_sequence[extension_core_start_idx:extension_core_start_idx + pe_format_length][pam_start_idx:pam_end_idx]\n                    \n                    ## Annotate pegRNA\n                    # Check if PAM is mutated relative to reference sequence\n                    if pam_ref == pam_edit.upper():\n                        pe_annotate = 'PAM_intact'\n\n                    else:\n                        # Check to see if mutation disrupts degenerate base positions within PAM\n                        if re.search(pam_search, pam_edit.upper()):\n                            pe_annotate = 'PAM_intact'\n\n                        else:\n                            pe_annotate = 'PAM_disrupted'\n\n                    # Store pegRNA spacer\n                    nick_ref_idx = match[0] + cut_idx\n                    nick_edit_idx = extension_core_start_idx + cut_idx\n                    target_design[target_name]['pegRNA']['+'].append([nick_ref_idx, nick_edit_idx, full_search, spacer_sequence, pam_ref, pam_edit, pe_annotate])\n\n                except:\n                    continue\n\n        # Find pegRNA spacers targeting (-) strand\n        if find_guides_ref_minus:\n\n            for match in find_guides_ref_minus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = reference_sequence[match[0]:match[0] + pe_format_length]\n                spacer_sequence = full_search[pe_format_length - spacer_end_idx:pe_format_length - spacer_start_idx]\n                extension_core_sequence = full_search[pe_format_length - cut_idx:]\n                downstream_sequence_ref = full_search[:pe_format_length - cut_idx]\n                downstream_sequence_length = len(downstream_sequence_ref)\n                pam_ref = full_search[pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n\n                # Check to see if the extended non target strand is conserved in the edited strand\n                try:\n                    extension_core_start_idx, extension_core_end_idx = re.search(extension_core_sequence, edit_sequence).start(), re.search(extension_core_sequence, edit_sequence).end()\n                    downstream_sequence_edit = edit_sequence[extension_core_start_idx - downstream_sequence_length:extension_core_start_idx]\n                    pam_edit = edit_sequence[extension_core_end_idx - pe_format_length:extension_core_end_idx][pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n                    \n                    ## Annotate pegRNA\n                    # Check if PAM is mutated relative to reference sequence\n                    if pam_ref == pam_edit.upper():\n                        pe_annotate = 'PAM_intact'\n\n                    else:\n                        # Check to see if mutation disrupts degenerate base positions within PAM\n                        if re.search(reverse_complement(pam_search), pam_edit.upper()):\n                            pe_annotate = 'PAM_intact'\n\n                        else:\n                            pe_annotate = 'PAM_disrupted'\n\n                    # Store pegRNA spacer\n                    nick_ref_idx = match[0] + (pe_format_length - cut_idx)\n                    nick_edit_idx = extension_core_start_idx - downstream_sequence_length + (pe_format_length - cut_idx)\n                    target_design[target_name]['pegRNA']['-'].append([nick_ref_idx, nick_edit_idx, full_search, spacer_sequence, pam_ref, pam_edit, pe_annotate])\n\n                except:\n                    continue\n\n        # Find ngRNA spacers targeting (+) strand\n        if find_guides_editnumber_plus:\n\n            for match in find_guides_editnumber_plus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = editnumber_sequence[:match[0] + pam_length]\n                \n                full_search2ref = full_search\n                full_search2edit = full_search\n                for edit_number in editnumber2sequence:\n                    full_search2ref = full_search2ref.replace(str(edit_number), editnumber2sequence[edit_number][0])\n                    full_search2edit = full_search2edit.replace(str(edit_number), editnumber2sequence[edit_number][1])\n\n                if len(full_search2edit[-pe_format_length:]) == pe_format_length:\n\n                    # Identify ngRNA sequence information from edit sequence\n                    full_search_edit = full_search2edit[-pe_format_length:]\n                    spacer_sequence_edit = full_search_edit[spacer_start_idx:spacer_end_idx]\n                    pam_edit = full_search_edit[pam_start_idx:pam_end_idx]\n\n                    # Use reference sequence to find nick index\n                    full_search_ref = full_search2ref[-pe_format_length:]\n                    spacer_sequence_ref = full_search_ref[spacer_start_idx:spacer_end_idx]\n                    pam_ref = full_search_ref[pam_start_idx:pam_end_idx]\n\n                    # Annotate ngRNA\n                    if spacer_sequence_edit.upper() == spacer_sequence_ref.upper():\n                        ng_annotate = 'PE3'\n                    else:\n                        if spacer_sequence_edit.upper()[-10:] == spacer_sequence_ref.upper()[-10:]:\n                            ng_annotate = 'PE3b-nonseed'\n                        else:\n                            ng_annotate = 'PE3b-seed'\n\n                    # Store ngRNA spacer\n                    nick_ref_idx = re.search(full_search_ref, reference_sequence).end() - (pe_format_length - cut_idx)\n                    nick_edit_start_idx = re.search(spacer_sequence_edit, edit_sequence).start()\n                    nick_edit_end_idx = re.search(spacer_sequence_edit, edit_sequence).end()\n                    target_design[target_name]['ngRNA']['+'].append([nick_ref_idx, nick_edit_start_idx, nick_edit_end_idx, full_search_edit, spacer_sequence_edit, pam_edit, ng_annotate])\n\n        # Find ngRNA spacers targeting (-) strand\n        if find_guides_editnumber_minus:\n\n            for match in find_guides_editnumber_minus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = editnumber_sequence[match[0]:]\n                \n                full_search2ref = full_search\n                full_search2edit = full_search\n                for edit_number in editnumber2sequence:\n                    full_search2ref = full_search2ref.replace(str(edit_number), editnumber2sequence[edit_number][0])\n                    full_search2edit = full_search2edit.replace(str(edit_number), editnumber2sequence[edit_number][1])\n\n                if len(full_search2edit[:pe_format_length]) == pe_format_length:\n\n                    # Identify ngRNA sequence information from edit sequence\n                    full_search_edit = full_search2edit[:pe_format_length]\n                    spacer_sequence_edit = full_search_edit[pe_format_length - spacer_end_idx:pe_format_length - spacer_start_idx]\n                    pam_edit = full_search_edit[pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n\n                    # Use reference sequence to find nick index\n                    full_search_ref = full_search2ref[:pe_format_length]\n                    spacer_sequence_ref = full_search_ref[pe_format_length - spacer_end_idx:pe_format_length - spacer_start_idx]\n                    pam_ref = full_search_ref[pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n\n                    # Annotate ngRNA\n                    if spacer_sequence_edit.upper() == spacer_sequence_ref.upper():\n                        ng_annotate = 'PE3'\n                    else:\n                        if spacer_sequence_edit.upper()[:10] == spacer_sequence_ref.upper()[:10]:\n                            ng_annotate = 'PE3b-nonseed'\n                        else:\n                            ng_annotate = 'PE3b-seed'\n\n                    # Store ngRNA spacer\n                    nick_ref_idx = re.search(full_search_ref, reference_sequence).start() + (pe_format_length - cut_idx)\n                    nick_edit_start_idx = re.search(spacer_sequence_edit, edit_sequence).start()\n                    nick_edit_end_idx = re.search(spacer_sequence_edit, edit_sequence).end()\n                    target_design[target_name]['ngRNA']['-'].append([nick_ref_idx, nick_edit_start_idx, nick_edit_end_idx, full_search_edit, spacer_sequence_edit, pam_edit, ng_annotate])\n\n        # Grab index information of edits to introduce to target sequence\n        edit_start_in_ref = int(target_design[target_name]['edit_start_in_ref'])\n        edit_stop_in_ref_rev = int(target_design[target_name]['edit_stop_in_ref_rev'])\n        edit_span_length_w_ref = int(target_design[target_name]['edit_span_length'][0])\n        edit_span_length_w_edit = int(target_design[target_name]['edit_span_length'][1])\n\n        # Design pegRNAs targeting the (+) strand\n        counter = 1\n        counted = []\n        for peg_plus in target_design[target_name]['pegRNA']['+']:\n\n            pe_nick_ref_idx, pe_nick_edit_idx, pe_full_search, pe_spacer_sequence, pe_pam_ref, pe_pam_edit, pe_annotate = peg_plus\n            pegid = '_'.join(map(str, [pe_nick_ref_idx, pe_spacer_sequence, pe_pam_ref, pe_annotate, '+']))\n\n            pe_annotate_constant = pe_annotate\n\n            # See if pegRNA spacer can introduce all edits\n            nick2edit_length = edit_start_in_ref - pe_nick_ref_idx\n            if nick2edit_length >= 0:\n\n                # Loop through RTT lengths\n                silent_mutation_edit = ''\n                for rtt_length in rtt_length_list:\n\n                    # See if RT length can reach entire edit\n                    nick2lastedit_length = nick2edit_length + edit_span_length_w_edit\n                    if nick2lastedit_length < rtt_length:\n\n                        # Loop through PBS lengths\n                        for pbs_length in pbs_length_list:\n                            pe_pam_ref_silent_mutation = ''\n\n                            # Construct pegRNA extension to encode intended edit(s)\n                            if ((len(edit_sequence) - pe_nick_edit_idx) - rtt_length) < 0:\n                                rtt_length = len(edit_sequence) - pe_nick_edit_idx\n\n                            # Patch for NGG PAMs - may need to build something more generalizable in the future\n                            pegRNA_ext = reverse_complement(edit_sequence[pe_nick_edit_idx - pbs_length:pe_nick_edit_idx + rtt_length])\n\n                            # Check to see if pegRNA extension is within input sequence\n                            if len(pegRNA_ext) == (pbs_length + rtt_length):\n\n                                peg_design['pegRNA group'].append(counter)\n                                peg_design['type'].append('pegRNA')\n                                peg_design['spacer sequence'].append(pe_spacer_sequence)\n                                peg_design['spacer GC content'].append(gc_content(pe_spacer_sequence))\n\n                                if pe_pam_ref_silent_mutation == '':\n                                    peg_design['PAM'].append(pe_pam_ref)\n                                else:\n                                    peg_design['PAM'].append(pe_pam_ref_silent_mutation)\n\n                                peg_design['strand'].append('+')\n                                peg_design['peg-to-edit distance'].append(nick2lastedit_length)\n                                peg_design['nick-to-peg distance'].append('')\n                                peg_design['pegRNA extension'].append(pegRNA_ext)\n                                peg_design['extension first base'].append(pegRNA_ext[0])\n                                peg_design['PBS length'].append(pbs_length)\n                                peg_design['PBS GC content'].append(gc_content(pegRNA_ext[rtt_length:]))\n                                peg_design['PBS Tm'].append(mt.Tm_NN(pegRNA_ext[-pbs_length:], nn_table=mt.R_DNA_NN1))\n                                peg_design['RTT length'].append(rtt_length)\n                                peg_design['RTT GC content'].append(gc_content(pegRNA_ext[:rtt_length]))\n                                peg_design['annotation'].append(pe_annotate)\n                                peg_design['CFD score'].append('')\n\n                                if pe_spacer_sequence[0] == 'G':\n                                    peg_design['spacer top strand oligo'].append('cacc' + pe_spacer_sequence + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement(pe_spacer_sequence))\n\n                                else:\n                                    peg_design['spacer top strand oligo'].append('caccG' + pe_spacer_sequence + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement('G' + pe_spacer_sequence))\n\n                                peg_design['pegRNA extension top strand oligo'].append('gtgc' + pegRNA_ext)\n                                peg_design['pegRNA extension bottom strand oligo'].append('aaaa' + reverse_complement(pegRNA_ext))\n\n                                counted.append(counter)\n\n                # Create ngRNAs targeting (-) strand for (+) pegRNAs\n                if counter in counted:\n                    for ng_minus in target_design[target_name]['ngRNA']['-']:\n                        ng_nick_ref_idx, ng_edit_start_idx, ng_edit_end_idx, ng_full_search_edit, ng_spacer_sequence_edit, ng_pam_edit, ng_annotate = ng_minus\n                        nick_distance = ng_nick_ref_idx - pe_nick_ref_idx\n\n                        if (abs(nick_distance) >= nicking_distance_minimum) and (abs(nick_distance) <= nicking_distance_maximum):\n\n                            peg_design['pegRNA group'].append(counter)\n                            peg_design['type'].append('ngRNA')\n                            peg_design['spacer sequence'].append(reverse_complement(ng_spacer_sequence_edit))\n                            peg_design['spacer GC content'].append(gc_content(reverse_complement(ng_spacer_sequence_edit)))\n                            peg_design['PAM'].append(reverse_complement(ng_pam_edit))\n                            peg_design['strand'].append('-')\n                            peg_design['peg-to-edit distance'].append('')\n                            peg_design['nick-to-peg distance'].append(nick_distance)\n                            peg_design['pegRNA extension'].append('')\n                            peg_design['extension first base'].append('')\n                            peg_design['PBS length'].append('')\n                            peg_design['PBS GC content'].append('')\n                            peg_design['PBS Tm'].append('')\n                            peg_design['RTT length'].append('')\n                            peg_design['RTT GC content'].append('')\n                            peg_design['annotation'].append(ng_annotate)\n                            peg_design['CFD score'].append('')\n\n                            if reverse_complement(ng_spacer_sequence_edit)[0] == 'G':\n                                peg_design['spacer top strand oligo'].append('cacc' + reverse_complement(ng_spacer_sequence_edit))\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement(reverse_complement(ng_spacer_sequence_edit)))\n\n                            else:\n                                peg_design['spacer top strand oligo'].append('caccG' + reverse_complement(ng_spacer_sequence_edit))\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement('G' + reverse_complement(ng_spacer_sequence_edit)))\n\n                            peg_design['pegRNA extension top strand oligo'].append('')\n                            peg_design['pegRNA extension bottom strand oligo'].append('')\n\n                    counter += 1\n\n        # Design pegRNAs targeting the (-) strand\n        for peg_minus in target_design[target_name]['pegRNA']['-']:\n\n            pe_nick_ref_idx, pe_nick_edit_idx, pe_full_search, pe_spacer_sequence, pe_pam_ref, pe_pam_edit, pe_annotate = peg_minus\n            pegid = '_'.join(map(str, [pe_nick_ref_idx, pe_spacer_sequence, pe_pam_ref, pe_annotate, '-']))\n\n            pe_annotate_constant = pe_annotate\n\n            # See if pegRNA spacer can introduce all edits\n            nick2edit_length = edit_stop_in_ref_rev - (len(reference_sequence) - pe_nick_ref_idx)\n            if nick2edit_length >= 0:\n\n                # Loop through RTT lengths\n                silent_mutation_edit = ''\n                for rtt_length in rtt_length_list:\n\n                    # See if RT length can reach entire edit\n                    nick2lastedit_length = nick2edit_length + edit_span_length_w_edit\n                    if nick2lastedit_length < rtt_length:\n\n                        # Loop through PBS lengths\n                        for pbs_length in pbs_length_list:\n                            pe_pam_ref_silent_mutation = ''\n\n                            # Construct pegRNA extension to encode intended edit(s)\n                            # pegRNA_ext = edit_sequence[pe_nick_edit_idx - rtt_length:pe_nick_edit_idx + pbs_length]\n                            if (pe_nick_edit_idx - rtt_length) < 0:\n                                rtt_length = pe_nick_edit_idx\n\n                            # Patch for NGG PAMs - may need to build something more generalizable in the future\n                            pegRNA_ext = edit_sequence[pe_nick_edit_idx - rtt_length:pe_nick_edit_idx + pbs_length]\n\n                            # Check to see if pegRNA extension is within input sequence\n                            if len(pegRNA_ext) == (pbs_length + rtt_length):\n\n                                peg_design['pegRNA group'].append(counter)\n                                peg_design['type'].append('pegRNA')\n                                peg_design['spacer sequence'].append(reverse_complement(pe_spacer_sequence))\n                                peg_design['spacer GC content'].append(gc_content(reverse_complement(pe_spacer_sequence)))\n\n                                if pe_pam_ref_silent_mutation == '':\n                                    peg_design['PAM'].append(reverse_complement(pe_pam_ref))\n                                else:\n                                    peg_design['PAM'].append(pe_pam_ref_silent_mutation)\n\n                                peg_design['strand'].append('-')\n                                peg_design['peg-to-edit distance'].append(nick2lastedit_length)\n                                peg_design['nick-to-peg distance'].append('')\n                                peg_design['pegRNA extension'].append(pegRNA_ext)\n                                peg_design['extension first base'].append(pegRNA_ext[0])\n                                peg_design['PBS length'].append(pbs_length)\n                                peg_design['PBS GC content'].append(gc_content(pegRNA_ext[rtt_length:]))\n                                peg_design['PBS Tm'].append(mt.Tm_NN(pegRNA_ext[-pbs_length:], nn_table=mt.R_DNA_NN1))\n                                peg_design['RTT length'].append(rtt_length)\n                                peg_design['RTT GC content'].append(gc_content(pegRNA_ext[:rtt_length]))\n                                peg_design['annotation'].append(pe_annotate)\n                                peg_design['CFD score'].append('')\n\n                                if reverse_complement(pe_spacer_sequence)[0] == 'G':\n                                    peg_design['spacer top strand oligo'].append('cacc' + reverse_complement(pe_spacer_sequence) + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement(reverse_complement(pe_spacer_sequence)))\n\n                                else:\n                                    peg_design['spacer top strand oligo'].append('caccG' + reverse_complement(pe_spacer_sequence) + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement('G' + reverse_complement(pe_spacer_sequence)))\n\n                                peg_design['pegRNA extension top strand oligo'].append('gtgc' + pegRNA_ext)\n                                peg_design['pegRNA extension bottom strand oligo'].append('aaaa' + reverse_complement(pegRNA_ext))\n\n                                counted.append(counter)\n\n                # Create ngRNAs targeting (+) strand for (-) pegRNAs\n                if counter in counted:\n                    for ng_plus in target_design[target_name]['ngRNA']['+']:\n                        ng_nick_ref_idx, ng_edit_start_idx, ng_edit_end_idx, ng_full_search_edit, ng_spacer_sequence_edit, ng_pam_edit, ng_annotate = ng_plus\n                        nick_distance = ng_nick_ref_idx - pe_nick_ref_idx\n\n                        if (abs(nick_distance) >= nicking_distance_minimum) and (abs(nick_distance) <= nicking_distance_maximum):\n\n                            peg_design['pegRNA group'].append(counter)\n                            peg_design['type'].append('ngRNA')\n                            peg_design['spacer sequence'].append(ng_spacer_sequence_edit)\n                            peg_design['spacer GC content'].append(gc_content(ng_spacer_sequence_edit))\n                            peg_design['PAM'].append(ng_pam_edit)\n                            peg_design['strand'].append('+')\n                            peg_design['peg-to-edit distance'].append('')\n                            peg_design['nick-to-peg distance'].append(nick_distance)\n                            peg_design['pegRNA extension'].append('')\n                            peg_design['extension first base'].append('')\n                            peg_design['PBS length'].append('')\n                            peg_design['PBS GC content'].append('')\n                            peg_design['PBS Tm'].append('')\n                            peg_design['RTT length'].append('')\n                            peg_design['RTT GC content'].append('')\n                            peg_design['annotation'].append(ng_annotate)\n                            peg_design['CFD score'].append('')\n\n                            if ng_spacer_sequence_edit[0] == 'G':\n                                peg_design['spacer top strand oligo'].append('cacc' + ng_spacer_sequence_edit)\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement(ng_spacer_sequence_edit))\n\n                            else:\n                                peg_design['spacer top strand oligo'].append('caccG' + ng_spacer_sequence_edit)\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement('G' + ng_spacer_sequence_edit))\n\n                            peg_design['pegRNA extension top strand oligo'].append('')\n                            peg_design['pegRNA extension bottom strand oligo'].append('')\n\n                    counter += 1\n\n    df = pd.DataFrame.from_dict(peg_design)\n\n    try:\n        df = df[~df['spacer sequence'].str.contains('TTTT')]\n    except:\n        pass\n\n    df_pegs = df[df['type'] == 'pegRNA']\n\n    # Find recommended pegRNA\n    if len(df_pegs.sort_values(['annotation', 'peg-to-edit distance'])['pegRNA group']) > 0:\n\n        edit_effective_length = max([edit_span_length_w_ref, edit_span_length_w_edit])\n        if edit_effective_length <= 1:\n            homology_downstream_recommended = 9\n        elif edit_effective_length <= 5:\n            homology_downstream_recommended = 14\n        elif edit_effective_length <= 10:\n            homology_downstream_recommended = 19\n        elif edit_effective_length <= 15:\n            homology_downstream_recommended = 24\n        else:\n            homology_downstream_recommended = 34\n\n        pegrna_group = df_pegs.sort_values(['annotation', 'peg-to-edit distance'])['pegRNA group'].values[0]\n        rtt_length_recommended = min(df_pegs[df_pegs['pegRNA group'] == pegrna_group]['peg-to-edit distance']) + homology_downstream_recommended\n        rtt_max = max(df_pegs[(df_pegs['pegRNA group'] == pegrna_group)]['RTT length'].values)\n\n        # find recommended PBS\n        df_pegs['recommended_PBS_Tm'] = abs(df_pegs['PBS Tm'] - 37) # optimal PBS Tm of 37C\n        pbs_length_recommended = df_pegs[df_pegs['pegRNA group'] == pegrna_group].sort_values(['recommended_PBS_Tm'], ascending = [True])['PBS length'].values[0]\n\n        # find recommended RTT\n        extension_first_base = 'C'\n        while (extension_first_base == 'C') and (rtt_length_recommended < rtt_max):\n            rtt_length_recommended += 1\n            extension_first_base = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['pegRNA extension'].values[0][rtt_max-int(rtt_length_recommended):rtt_max][0]\n\n        if extension_first_base != 'C':\n\n            pbs_extension_recommended = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['pegRNA extension'].values[0][rtt_max:]\n            rtt_extension_max = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['pegRNA extension'].values[0][:rtt_max]\n            extension_recommended = rtt_extension_max[-rtt_length_recommended:] + pbs_extension_recommended\n\n            peg_spacer_top_recommended = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['spacer top strand oligo'].values[0]\n            peg_spacer_bottom_recommended = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['spacer bottom strand oligo'].values[0]\n            peg_ext_top_recommended = 'gtgc' + extension_recommended\n            peg_ext_bottom_recommended = 'aaaa' + reverse_complement(extension_recommended)\n\n            peg_annotation_recommended = ' %s' % str(df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['annotation'].values[0]).replace('_', ' ')\n            peg_pbs_recommended = '%s nt' % str(pbs_length_recommended)\n            peg_rtt_recommended = '%s nt' % str(rtt_length_recommended)\n\n            # Find recommended ngRNA\n            df_ngs = df[(df['type'] == 'ngRNA') & (df['pegRNA group'] == pegrna_group)]\n            df_ngs['optimal_distance'] = abs(abs(df_ngs['nick-to-peg distance']) - 75) # optimal ngRNA +/- 75 bp away\n            df_ngs = df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True]) # prioritize PE3b\n\n            if len(df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['spacer top strand oligo']) > 0:\n\n                ng_spacer_top_recommended = df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['spacer top strand oligo'].values[0]\n                ng_spacer_bottom_recommended = df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['spacer bottom strand oligo'].values[0]\n                ng_annotation_recommended = ' %s' % str(df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['annotation'].values[0]).replace('_', ' ')\n                ng_distance_recommended = ' %s bp' % str(df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['nick-to-peg distance'].values[0])\n\n            else:\n\n                ng_spacer_top_recommended = 'n/a'\n                ng_spacer_bottom_recommended = 'n/a'\n                ng_annotation_recommended = 'n/a'\n                ng_distance_recommended = 'n/a'\n\n        else:\n\n            peg_spacer_top_recommended = 'n/a'\n            peg_spacer_bottom_recommended = 'n/a'\n            peg_ext_top_recommended = 'n/a'\n            peg_ext_bottom_recommended = 'n/a'\n\n            peg_annotation_recommended = ' n/a'\n            peg_pbs_recommended = ' n/a'\n            peg_rtt_recommended = ' n/a'\n\n            ng_spacer_top_recommended = 'n/a'\n            ng_spacer_bottom_recommended = 'n/a'\n            ng_annotation_recommended = ' n/a'\n            ng_distance_recommended = ' n/a'\n\n    else:\n\n        peg_spacer_top_recommended = ''\n        peg_spacer_bottom_recommended = ''\n        peg_ext_top_recommended = ''\n        peg_ext_bottom_recommended = ''\n\n        peg_annotation_recommended = ''\n        peg_pbs_recommended = ''\n        peg_rtt_recommended = ''\n\n        ng_spacer_top_recommended = ''\n        ng_spacer_bottom_recommended = ''\n        ng_annotation_recommended = ''\n        ng_distance_recommended = ''\n\n    '''\n    # Filter dataframes\n    df = df[(df['extension first base'] != 'C')]\n\n    pbs_range_list = list(range(12, 14 + 1)) + ['']\n    rtt_range_list = list(range(10, 20 + 1)) + ['']\n\n    pegrna_groups_to_keep = list(set(df_pegs[df_pegs['RTT length'].isin(rtt_range_list)]['pegRNA group'].values))\n\n    df = df[df['PBS length'].isin(pbs_range_list)]\n    df_pegs = df_pegs[df_pegs['PBS length'].isin(pbs_range_list)]\n\n    df = df[df['RTT length'].isin(rtt_range_list)]\n    df_pegs = df_pegs[df_pegs['RTT length'].isin(rtt_range_list)]\n\n    df = df[df['pegRNA group'].isin(pegrna_groups_to_keep)]\n    df_pegs = df_pegs[df_pegs['pegRNA group'].isin(pegrna_groups_to_keep)]\n\n    df.reset_index(drop=True, inplace=True)\n\n    df_pegs = df_pegs[['pegRNA group','spacer sequence','PAM','strand','peg-to-edit distance','spacer GC content','annotation']].drop_duplicates()\n    df_pegs = df_pegs.sort_values('peg-to-edit distance')\n    df_pegs.reset_index(drop=True, inplace=True)\n    #return df_pegs, df, peg_spacer_top_recommended, peg_spacer_bottom_recommended, peg_ext_top_recommended, peg_ext_bottom_recommended, peg_annotation_recommended, peg_pbs_recommended, peg_rtt_recommended, ng_spacer_top_recommended, ng_spacer_bottom_recommended, ng_annotation_recommended, ng_distance_recommended\n    '''\n    if peg_spacer_top_recommended == '' and peg_spacer_bottom_recommended == '' and peg_ext_top_recommended == '' and peg_ext_bottom_recommended == '' and peg_annotation_recommended == '' and peg_pbs_recommended == '' and peg_rtt_recommended == '' and ng_spacer_top_recommended == '' and ng_spacer_bottom_recommended == '' and ng_annotation_recommended == '' and ng_distance_recommended == '':\n        return \"No PrimeDesign Recommended Guides\"\n    elif peg_spacer_top_recommended == 'n/a' and peg_spacer_bottom_recommended == 'n/a' and peg_ext_top_recommended == 'n/a' and peg_ext_bottom_recommended == 'n/a' and peg_annotation_recommended == ' n/a' and peg_pbs_recommended == ' n/a' and peg_rtt_recommended == ' n/a' and ng_spacer_top_recommended == 'n/a' and ng_spacer_bottom_recommended == 'n/a' and ng_annotation_recommended == ' n/a' and ng_distance_recommended == ' n/a':\n        return \"No PrimeDesign Recommended Guides\"\n    else:\n        return (peg_spacer_top_recommended, peg_spacer_bottom_recommended, peg_ext_top_recommended, peg_ext_bottom_recommended, peg_annotation_recommended, peg_pbs_recommended, peg_rtt_recommended, ng_spacer_top_recommended, ng_spacer_bottom_recommended, ng_annotation_recommended, ng_distance_recommended)\n", "type": "text"}, {"name": "calculate_scores.py", "content": "import math\nfrom typing import List, Tuple\nimport argparse\nfrom typing import Dict, Tuple\nimport pandas as pd\n\n# Parameters for on target scoring\nparams: List[Tuple[int, str, float]] = [\n    (1, 'G', -0.2753771), (2, 'A', -0.3238875), (2, 'C', 0.17212887), (3, 'C', -0.1006662),\n    (4, 'C', -0.2018029), (4, 'G', 0.24595663), (5, 'A', 0.03644004), (5, 'C', 0.09837684),\n    (6, 'C', -0.7411813), (6, 'G', -0.3932644), (11, 'A', -0.466099), (14, 'A', 0.08537695),\n    (14, 'C', -0.013814), (15, 'A', 0.27262051), (15, 'C', -0.1190226), (15, 'T', -0.2859442),\n    (16, 'A', 0.09745459), (16, 'G', -0.1755462), (17, 'C', -0.3457955), (17, 'G', -0.6780964),\n    (18, 'A', 0.22508903), (18, 'C', -0.5077941), (19, 'G', -0.4173736), (19, 'T', -0.054307),\n    (20, 'G', 0.37989937), (20, 'T', -0.0907126), (21, 'C', 0.05782332), (21, 'T', -0.5305673),\n    (22, 'T', -0.8770074), (23, 'C', -0.8762358), (23, 'G', 0.27891626), (23, 'T', -0.4031022),\n    (24, 'A', -0.0773007), (24, 'C', 0.28793562), (24, 'T', -0.2216372), (27, 'G', -0.6890167),\n    (27, 'T', 0.11787758), (28, 'C', -0.1604453), (29, 'G', 0.38634258), (1, 'GT', -0.6257787),\n    (4, 'GC', 0.30004332), (5, 'AA', -0.8348362), (5, 'TA', 0.76062777), (6, 'GG', -0.4908167),\n    (11, 'GG', -1.5169074), (11, 'TA', 0.7092612), (11, 'TC', 0.49629861), (11, 'TT', -0.5868739),\n    (12, 'GG', -0.3345637), (13, 'GA', 0.76384993), (13, 'GC', -0.5370252), (16, 'TG', -0.7981461),\n    (18, 'GG', -0.6668087), (18, 'TC', 0.35318325), (19, 'CC', 0.74807209), (19, 'TG', -0.3672668),\n    (20, 'AC', 0.56820913), (20, 'CG', 0.32907207), (20, 'GA', -0.8364568), (20, 'GG', -0.7822076),\n    (21, 'TC', -1.029693), (22, 'CG', 0.85619782), (22, 'CT', -0.4632077), (23, 'AA', -0.5794924),\n    (23, 'AG', 0.64907554), (24, 'AG', -0.0773007), (24, 'CG', 0.28793562), (24, 'TG', -0.2216372),\n    (26, 'GT', 0.11787758), (28, 'GG', -0.69774)\n]\n\n#  mismatch scores and PAM scores dictionaries for off target scoring \nmismatch_scores: Dict[str, float] = {\n    'rU:dT,12': 0.8, 'rU:dT,13': 0.692307692, 'rU:dC,5': 0.64,\n    'rG:dA,14': 0.266666667, 'rG:dG,19': 0.448275862, 'rG:dG,18': 0.476190476,\n    'rG:dG,15': 0.272727273, 'rG:dG,14': 0.428571429, 'rG:dG,17': 0.235294118,\n    'rG:dG,16': 0.0, 'rC:dC,20': 0.058823529, 'rG:dT,20': 0.9375,\n    'rG:dG,13': 0.421052632, 'rG:dG,12': 0.529411765, 'rU:dC,6': 0.571428571,\n    'rU:dG,14': 0.285714286, 'rU:dT,18': 0.666666667, 'rA:dG,13': 0.210526316,\n    'rA:dG,12': 0.263157895, 'rA:dG,11': 0.4, 'rA:dG,10': 0.333333333,\n    'rA:dA,19': 0.538461538, 'rA:dA,18': 0.5, 'rA:dG,15': 0.272727273,\n    'rA:dG,14': 0.214285714, 'rA:dA,15': 0.2, 'rA:dA,14': 0.533333333,\n    'rA:dA,17': 0.133333333, 'rA:dA,16': 0.0, 'rA:dA,11': 0.307692308,\n    'rA:dA,10': 0.882352941, 'rA:dA,13': 0.3, 'rA:dA,12': 0.333333333,\n    'rG:dA,13': 0.3, 'rG:dA,12': 0.384615385, 'rG:dA,11': 0.384615385,\n    'rG:dA,10': 0.8125, 'rG:dA,17': 0.25, 'rG:dA,16': 0.0, 'rG:dA,15': 0.142857143,\n    'rG:dA,6': 0.666666667, 'rG:dG,20': 0.428571429, 'rG:dA,19': 0.666666667,\n    'rG:dA,18': 0.666666667, 'rU:dC,4': 0.625, 'rG:dT,12': 0.933333333,\n    'rG:dT,13': 0.923076923, 'rU:dG,11': 0.666666667, 'rC:dA,3': 0.6875,\n    'rC:dA,2': 0.909090909, 'rC:dA,1': 1.0, 'rC:dA,7': 0.8125,\n    'rC:dA,6': 0.928571429, 'rC:dA,5': 0.636363636, 'rC:dA,4': 0.8,\n    'rC:dA,9': 0.875, 'rC:dA,8': 0.875, 'rU:dT,6': 0.866666667,\n    'rA:dG,20': 0.227272727, 'rG:dT,18': 0.692307692, 'rU:dG,10': 0.533333333,\n    'rG:dT,19': 0.714285714, 'rG:dA,20': 0.7, 'rC:dT,20': 0.5,\n    'rU:dC,2': 0.84, 'rG:dG,10': 0.4, 'rC:dA,17': 0.466666667,\n    'rC:dA,16': 0.307692308, 'rC:dA,15': 0.066666667, 'rC:dA,14': 0.733333333,\n    'rC:dA,13': 0.7, 'rC:dA,12': 0.538461538, 'rC:dA,11': 0.307692308,\n    'rC:dA,10': 0.941176471, 'rG:dG,11': 0.428571429, 'rU:dC,20': 0.176470588,\n    'rG:dG,3': 0.384615385, 'rC:dA,19': 0.461538462, 'rC:dA,18': 0.642857143,\n    'rU:dG,17': 0.705882353, 'rU:dG,16': 0.666666667, 'rU:dG,15': 0.272727273,\n    'rG:dG,2': 0.692307692, 'rU:dG,13': 0.789473684, 'rU:dG,12': 0.947368421,\n    'rG:dA,9': 0.533333333, 'rG:dA,8': 0.625, 'rG:dA,7': 0.571428571,\n    'rG:dG,5': 0.785714286, 'rG:dA,5': 0.3, 'rG:dA,4': 0.363636364,\n    'rG:dA,3': 0.5, 'rG:dA,2': 0.636363636, 'rG:dA,1': 1.0,\n    'rG:dG,4': 0.529411765, 'rG:dG,1': 0.714285714, 'rA:dC,9': 0.666666667,\n    'rG:dG,7': 0.6875, 'rG:dT,5': 0.866666667, 'rU:dT,20': 0.5625,\n    'rC:dC,15': 0.05, 'rC:dC,14': 0.0, 'rC:dC,17': 0.058823529,\n    'rC:dC,16': 0.153846154, 'rC:dC,11': 0.25, 'rC:dC,10': 0.388888889,\n    'rC:dC,13': 0.136363636, 'rC:dC,12': 0.444444444, 'rC:dA,20': 0.3,\n    'rC:dC,19': 0.125, 'rC:dC,18': 0.133333333, 'rA:dA,1': 1.0,\n    'rA:dA,3': 0.705882353, 'rA:dA,2': 0.727272727, 'rA:dA,5': 0.363636364,\n    'rA:dA,4': 0.636363636, 'rA:dA,7': 0.4375, 'rA:dA,6': 0.714285714,\n    'rA:dA,9': 0.6, 'rA:dA,8': 0.428571429, 'rU:dG,20': 0.090909091,\n    'rC:dC,9': 0.619047619, 'rC:dC,8': 0.642857143, 'rU:dT,10': 0.857142857,\n    'rU:dT,11': 0.75, 'rU:dT,16': 0.909090909, 'rU:dT,17': 0.533333333,\n    'rU:dT,14': 0.619047619, 'rU:dT,15': 0.578947368, 'rC:dC,1': 0.913043478,\n    'rU:dT,3': 0.714285714, 'rC:dC,3': 0.5, 'rC:dC,2': 0.695652174,\n    'rC:dC,5': 0.6, 'rC:dC,4': 0.5, 'rC:dC,7': 0.470588235,\n    'rC:dC,6': 0.5, 'rU:dT,4': 0.476190476, 'rU:dT,8': 0.8,\n    'rU:dT,9': 0.928571429, 'rA:dC,19': 0.375, 'rA:dC,18': 0.4,\n    'rA:dC,17': 0.176470588, 'rA:dC,16': 0.192307692, 'rA:dC,15': 0.65,\n    'rA:dC,14': 0.466666667, 'rA:dC,13': 0.652173913, 'rA:dC,12': 0.722222222,\n    'rA:dC,11': 0.65, 'rA:dC,10': 0.555555556, 'rU:dC,7': 0.588235294,\n    'rC:dT,8': 0.65, 'rC:dT,9': 0.857142857, 'rC:dT,6': 0.928571429,\n    'rC:dT,7': 0.75, 'rC:dT,4': 0.842105263, 'rC:dT,5': 0.571428571,\n    'rC:dT,2': 0.727272727, 'rC:dT,3': 0.866666667, 'rC:dT,1': 1.0,\n    'rA:dC,8': 0.733333333, 'rU:dT,1': 1.0, 'rU:dC,3': 0.5,\n    'rU:dC,1': 0.956521739, 'rU:dT,2': 0.846153846, 'rU:dG,19': 0.275862069,\n    'rG:dT,14': 0.75, 'rG:dT,15': 0.941176471, 'rG:dT,16': 1.0,\n    'rG:dT,17': 0.933333333, 'rG:dT,10': 0.933333333, 'rG:dT,11': 1.0,\n    'rA:dG,9': 0.571428571, 'rA:dG,8': 0.428571429, 'rA:dG,7': 0.4375,\n    'rA:dG,6': 0.454545455, 'rA:dG,5': 0.5, 'rA:dG,4': 0.352941176,\n    'rA:dG,3': 0.428571429, 'rA:dG,2': 0.785714286, 'rA:dG,1': 0.857142857,\n    'rU:dT,5': 0.5, 'rG:dT,2': 0.846153846, 'rA:dC,3': 0.611111111,\n    'rA:dC,20': 0.764705882, 'rG:dT,1': 0.9, 'rG:dT,6': 1.0,\n    'rG:dT,7': 1.0, 'rG:dT,4': 0.9, 'rC:dT,19': 0.428571429,\n    'rG:dG,9': 0.538461538, 'rG:dG,8': 0.615384615, 'rG:dT,8': 1.0,\n    'rG:dT,9': 0.642857143, 'rU:dG,18': 0.428571429, 'rU:dT,7': 0.875,\n    'rG:dG,6': 0.681818182, 'rA:dA,20': 0.6, 'rU:dC,9': 0.619047619,\n    'rA:dG,17': 0.176470588, 'rU:dC,8': 0.733333333, 'rA:dG,16': 0.0,\n    'rA:dG,19': 0.206896552, 'rG:dT,3': 0.75, 'rU:dG,3': 0.428571429,\n    'rU:dG,2': 0.857142857, 'rU:dG,1': 0.857142857, 'rA:dG,18': 0.19047619,\n    'rU:dG,7': 0.6875, 'rU:dG,6': 0.909090909, 'rU:dG,5': 1.0,\n    'rU:dG,4': 0.647058824, 'rU:dG,9': 0.923076923, 'rU:dG,8': 1.0,\n    'rU:dC,19': 0.25, 'rU:dC,18': 0.333333333, 'rU:dC,13': 0.260869565,\n    'rU:dC,12': 0.5, 'rU:dC,11': 0.4, 'rU:dC,10': 0.5,\n    'rU:dC,17': 0.117647059, 'rU:dC,16': 0.346153846, 'rU:dC,15': 0.05,\n    'rU:dC,14': 0.0, 'rC:dT,10': 0.866666667, 'rC:dT,11': 0.75,\n    'rC:dT,12': 0.714285714, 'rC:dT,13': 0.384615385, 'rC:dT,14': 0.35,\n    'rC:dT,15': 0.222222222, 'rC:dT,16': 1.0, 'rC:dT,17': 0.466666667,\n    'rC:dT,18': 0.538461538, 'rA:dC,2': 0.8, 'rA:dC,1': 1.0,\n    'rA:dC,7': 0.705882353, 'rA:dC,6': 0.714285714, 'rA:dC,5': 0.72,\n    'rA:dC,4': 0.625, 'rU:dT,19': 0.285714286,\n}\n\npam_scores: Dict[str, float] = {\n    'AA': 0.0, 'AC': 0.0, 'GT': 0.016129032, 'AG': 0.259259259,\n    'CC': 0.0, 'CA': 0.0, 'CG': 0.107142857, 'TT': 0.0,\n    'GG': 1.0, 'GC': 0.022222222, 'AT': 0.0, 'GA': 0.069444444,\n    'TG': 0.038961039, 'TA': 0.0, 'TC': 0.0, 'CT': 0.0,\n}\n\nintercept = 0.59763615\ngcHigh = -0.1665878\ngcLow = -0.2026259\n\ndef calculate_on_target_scores(seqs: List[str]) -> pd.DataFrame:\n    scores = []\n    for seq in seqs:\n        score = intercept\n        guide_seq = seq[4:24]\n        gc_count = guide_seq.count(\"G\") + guide_seq.count(\"C\")\n        if gc_count <= 10:\n            gc_weight = gcLow\n        else:\n            gc_weight = gcHigh\n        score += abs(10 - gc_count) * gc_weight\n\n        for pos, model_seq, weight in params:\n            sub_seq = seq[pos:pos + len(model_seq)]\n            if sub_seq == model_seq:\n                score += weight\n        Score = 1.0 / (1.0 + math.exp(-score))\n        scores.append((seq, Score))\n    \n    # Create a DataFrame for the results\n    on_target_scores_df = pd.DataFrame(scores, columns=['sequence', 'score'])\n    on_target_scores_df['score'] = on_target_scores_df['score'].round(3)*100\n    return on_target_scores_df\n\n\n\n\n\n#Everything below is in relation to off target scoring\ndef get_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(description='Calculates CFD score')\n    parser.add_argument('--wt', type=str, required=True, help='WT 23mer sgRNA sequence')\n    parser.add_argument('--off', type=str, required=True, help='Off-target 23mer sgRNA sequence')\n    return parser\n\n# Reverse complements a given string\ndef revcom(s: str) -> str:\n    basecomp = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A', 'U': 'A'}\n    letters = [basecomp[base] for base in s[::-1]]\n    return ''.join(letters)\n\n\ndef calculate_off_target_scores(wt_sequences: List[str], sg_sequences: List[str], pam_sequences: List[str]) -> pd.DataFrame:\n    scores = []\n    for wt, sg, pam in zip(wt_sequences, sg_sequences, pam_sequences):\n        score = 1.0\n        sg = sg.replace('T', 'U')\n        wt = wt.replace('T', 'U')\n        s_list = list(sg)\n        wt_list = list(wt)\n\n        for i, sl in enumerate(s_list):\n            if wt_list[i] == sl:\n                score *= 1\n            else:\n                key = f'r{wt_list[i]}:d{revcom(sl)},{i+1}'\n                score *= mismatch_scores.get(key, 1.0)\n\n        score *= pam_scores.get(pam, 1.0)\n        scores.append((wt, sg, pam, score))\n\n    # Create a DataFrame for the results\n    cfd_scores_df = pd.DataFrame(scores, columns=['spacer', 'protospacer', 'pam', 'score'])\n    \n    return cfd_scores_df\n\n\n", "type": "text"}]
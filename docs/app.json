[
    {
        "name": "app.py",
        "content": "import asyncio\nimport os\nimport pandas as pd\nimport re\nfrom datetime import date\nfrom datetime import datetime\nfrom pathlib import Path\nfrom utils import get_guides, almost_reverse_complement, editor_data, determine_mutation_type, process_guide_rnas, get_cloning_url\nfrom shiny import App, render, ui, reactive\nfrom shiny.types import ImgData\n\nimport numpy as np\n\nbases = {\"A\", \"C\", \"G\", \"T\"}\naccepted_bases = {\"A\", \"C\", \"G\", \"T\", \"-\"}\n\n\n# A card component wrapper.\ndef ui_card(title, id, *args):\n    return (\n        ui.div(\n            {\"class\": \"card mb-4\"},\n            ui.div(title, class_=\"card-header\"),\n            ui.div({\"class\": \"card-body\", \"id\" : id}, *args),\n        ),\n    )\n\napp_ui = ui.page_fluid(\n    {\"id\": \"main-content\"},\n    ui.output_image(\"display_logo\", inline=True),\n    ui.output_image(\"stanford_logo\", inline=True),\n    ui.br(),\n    ui.help_text(\n        '''Welcome to editABLE! We have designed this tool to help to determine the type of gene editing most appropriate for a single gene edit. We prioritize finding base \n        editing reagents, as they have higher reported editing efficiency. Under conditions where base editing is not currently possible, we provide a first pass analysis for \n        reagents needed for prime editing. Please refer to the following papers for more information on base and prime editing:'''\n    ),\n    ui.br(),\n    ui.br(),\n    ui.help_text(ui.tags.a('Komor AC, Kim YB, Packer MS, Zuris JA, Liu DR. Programmable editing of a target base in genomic DNA without double-stranded DNA cleavage. Nature. 2016;533(7603):420-424.', {'href' : 'https://pubmed.ncbi.nlm.nih.gov/27096365/', 'target' : '_blank'})),\n    ui.br(),\n    ui.br(),\n    ui.help_text(ui.tags.a('Gaudelli NM, Komor AC, Rees HA, et al. Programmable base editing of A\u2022T to G\u2022C in genomic DNA without DNA cleavage. Nature. 2017;551(7681):464-471.', {'href' : 'https://pubmed.ncbi.nlm.nih.gov/29160308/', 'target' : '_blank'})),\n    ui.br(),\n    ui.br(),\n    ui.help_text(ui.tags.a('Anzalone AV, Randolph PB, Davis JR, et al. Search-and-replace genome editing without double-strand breaks or donor DNA. Nature. 2019;576(7785):149-157.', {'href' : 'https://pubmed.ncbi.nlm.nih.gov/31634902/', 'target' : '_blank'})),\n    ui.br(),\n    ui.br(),\n    ui.help_text(ui.tags.a('Doman JL, Pandey S, Neugebauer ME, et al. Phage-assisted evolution and protein engineering yield compact, efficient prime editors. Cell. 2023;186(18):3983-4002.e26.', {'href' : 'https://pubmed.ncbi.nlm.nih.gov/37657419/', 'target' : '_blank'})),\n    ui.br(),\n    ui.br(),\n    ui_card(\n        \"How to use this app\",\n        \"how_to_app\",\n        ui.help_text(\n            '''In CRISPR editing experiments, one is trying to induce some change in a DNA sequence.\n             Therefore, you have an original sequence you are trying to change and a desired sequence \n             (what you want your sequence to look like after the CRISPR edit).'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"There are two ways to use this app:\"),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''1. If you want to find guides for a single CRISPR edit. For this use case, please enter \n            in your original sequence and desired sequence in their respective input boxes.'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''2. If you have more than one CRISPR edit you want to make, you can upload a CSV file with \n            two columns, named \"Original Sequence\" and \"Desired Sequence\" that contain your original and \n            desired sequences, with each row representing one edit you would like to make. Then click the \n            blue \"Upload File\" button even if the progress bar under the file browser says \"Upload complete\"'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''After specifing your input, click the \"Find Guides\" button and editABLE will try to find CRISPR \n            guides that will induce your desired edits. Once editABLE finishes running, a table will appear \n            displaying either the guides that editABLE has found for each of your desired edits or a suggestion to \n            use an alternative CRISPR technology if base or prime editing guides can't be found. Lastly, you can \n            download a CSV of the guides found by editABLE by clicking on the \"Download Results as CSV File\" \n            button. Base editing reagents will be suggested first due to their higher reported editing efficiency. \n            If a base editing guide cannot be found, we will then provide suggested prime editing reagents if possible.'''\n        )\n    ),\n    ui_card(\n        \"Input requirements\",\n        \"input_recs\",\n        ui.help_text(\n            '''Your original sequence(s) and the desired sequence(s) must be the same length. Only single edits \n            (SNV, insertion, deletion) are supported at this time. Only the following characters are allowed in the input\n            (\"A\", \"C\", \"G\", \"T\", \"a\", \"c\", \"g\", \"t\", \"-\"). All whitespace is allowed but will be removed before running our pipeline.\n            Your sequences need to be from 5' to 3'.'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''For single nucleotide variant (SNV) edits, the input sequences are the most straightforward. You can \n            input the original and desired sequences without modification. For example, this would be a valid set of inputs:'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Original Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"A\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Desired Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"T\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''For changes that result in deletions, use a string of \"-\" characters in the desired sequence to denote the \n            area of the deletion. For example, this would be a valid set of inputs for a deletion:'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Original Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"ATT\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Desired Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"---\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''For changes that result in insertions/duplications, use a string of \"-\" characters in the original sequence \n            to denote the area of the insertion/duplication. For example, this would be a valid set of inputs for a insertions/duplications:'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Original Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"---\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\"Desired Sequence:\"),\n        ui.br(),\n        ui.help_text(\n            ui.tags.b(\"GATAGCTCAGCTAGCCTAGTCAAACCTATC\", style=\"font-family: Courier,courier\"), \n            ui.tags.b(\"GCG\", style=\"color: red; font-family: Courier,courier\"), \n            ui.tags.b(\"ACGTCGATCGATCGATCACACCGCCTAATC\", style=\"font-family: Courier,courier\"),\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''Then, use the \"Select Desired Base Editing PAM\" dropdown to select the base editing PAM that is desired.'''\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            '''Lastly, we require at least 25 base pairs of sequence to the left and right of your desired ''',\n            ui.tags.b(\"edit\", style=\"color: red\"),\n            '''. So in each of the examples above, there must be 25 or more base pairs to the right and left \n            of the ''',\n            ui.tags.b(\"red\", style=\"color: red\"),\n            ''' highlighted regions.'''\n        )\n    ),\n    ui_card(\n        \"Input\",\n        'input',\n        ui.input_text_area(\"ref_sequence_input\", \"Original Sequence\", placeholder=\"Enter sequence\", height=\"50%\", width=\"100%\"),\n        ui.input_text_area(\"edited_sequence_input\", \"Desired Sequence\", placeholder=\"Enter sequence\", height=\"50%\", width=\"100%\"),\n        ui.output_ui(\"ui_input_file\"),\n        ui.input_action_button(\"upload\", \"Upload File\", class_=\"btn-primary\"),\n        ui.output_ui(\"upload_status\"),\n        ui.br(),\n        ui.input_select(\"pam_type\", \"Select Desired Base Editing PAM\", {\"NGN\": \"NGN (Recommended)\", \"NGG\": \"NGG (Most Efficient)\", \"NGA\" : \"NGA\", \"NNGRRT\" : \"NNGRRT (SaCas9)\", \"NNNRRT\" : \"NNNRRT (SaCas9-KKH)\", \"NRN\" : \"NRN (SpRY)\"}),\n        ui.input_action_button(\"get_guides\", \"Find Guides\", class_=\"btn-primary\"),\n        ui.help_text(\" \"),\n        ui.input_action_button(\"clear\", \"Clear Inputs\", class_=\"btn-danger\"),\n    ),\n    ui.output_ui(\"run\"),\n    ui.br(),\n    ui.help_text(\n        '''For base editing, EditABLE finds guide RNAs where the editable base is in positions 4-9 starting from the 5' \n           end of the guide RNA. Note that guide RNAs with base edits outside of this editing range may still work but \n           tend to be significantly less efficient.'''\n    ),\n    ui.br(),\n    ui.br(),\n    ui.help_text(\n        '''Note that we use PrimeDesign (Hsu, J.Y., Gr\u00fcnewald, J., Szalay, R. et al. \n        PrimeDesign software for rapid and simplified design of prime editing guide RNAs. \n        Nat Commun 12, 1034 (2021)) for prime editing guide calcualtions. We run PrimeDesign \n        with default parameters and take only the suggested guides. For more advanced usage \n        please use the ''',\n        ui.tags.a('PrimeDesign portal', {'href' : 'https://primedesign.pinellolab.partners.org/', 'target' : '_blank'}),\n        ''' (https://primedesign.pinellolab.partners.org/) to design your Prime Editing guides.'''\n    ),\n    ui.br(),\n    ui.br(),\n    ui.help_text(\n        '''For troubleshooting and suggested revisions, please contact the ''',\n        ui.tags.a(\"Bhalla Lab\", {'href' : 'https://med.stanford.edu/bhallalab.html', 'target' : '_blank'}),\n        \" at vbhalla@stanford.edu\"\n    ),\n    ui.br(),\n    ui.br(),\n    ui.br(),\n    ui.br(),\n)\n\ndef check_ref_edited_pair(ref_sequence, edited_sequence):\n    if len(ref_sequence) == 0 or len(edited_sequence) == 0:\n        return False, \"Both the original sequence and the edited sequence must be of nonzero length.\"\n    if len(ref_sequence) != len(edited_sequence):\n        return False, \"The length of the original sequence and the edited sequence must be the same.\"\n    if ref_sequence == edited_sequence:\n        return False, \"The original sequence and the edited sequence are the same.\"\n    if len(set(ref_sequence) - accepted_bases) != 0 or len(set(edited_sequence) - accepted_bases) != 0:\n        return False, \"You may only have the following characters in your sequences {A, C, G, T, a, c, g, t, -}.\"\n    if len(set(ref_sequence) - bases) == 0 and len(set(edited_sequence) - bases) == 0:\n        substitution_position = None\n        for i in range(len(ref_sequence)):\n            ref_base = ref_sequence[i]\n            edited_base = edited_sequence[i]\n            if ref_base != edited_base:\n                if substitution_position is not None:\n                    return False, \"The original sequence and the edited sequence contain more than one SNV. EditABLE currently only supports single SNVs, insertions, or deletions.\"\n                else:\n                    substitution_position = i\n        if substitution_position < 25:\n            return False, f\"There must be at least 25 base pairs of sequence before the desired edit. {substitution_position} base pairs were found before your edit.\"\n        if len(ref_sequence) - 1 - substitution_position < 25:\n            return False, f\"There must be at least 25 base pairs of sequence after the desired edit. {len(ref_sequence) - 1 - substitution_position} base pairs were found after your edit.\"\n    else:\n        if '-' not in ref_sequence and '-' not in edited_sequence:\n            return False, 'The lengths of the original sequence and the edited sequence are not the same but neither has a \"-\" in it.'\n        if '-' in ref_sequence and '-' in edited_sequence:\n            return False, 'You cannot have a \"-\" in both the original and edited sequences.'\n        elif '-' in ref_sequence:\n            start_dash_position = None\n            current_dash_position = None\n            for i in range(len(ref_sequence)):\n                if ref_sequence[i] == '-':\n                    if start_dash_position is None:\n                        start_dash_position = i\n                    if current_dash_position is not None and i - current_dash_position != 1:\n                        return False, 'The \"-\" characters are not contiguous, indicating that there are multiple insertions. EditABLE currently only supports single SNVs, insertions, or deletions.'\n                    else:\n                        current_dash_position = i\n            if start_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence before the desired edit. {start_dash_position} base pairs were found before your edit.\"\n            if len(ref_sequence) - 1 - current_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence after the desired edit. {len(ref_sequence) - 1 - current_dash_position} base pairs were found after your edit.\"\n        else:\n            start_dash_position = None\n            current_dash_position = None\n            for i in range(len(edited_sequence)):\n                if edited_sequence[i] == '-':\n                    if start_dash_position is None:\n                        start_dash_position = i\n                    if current_dash_position is not None and i - current_dash_position != 1:\n                        return False, 'The \"-\" characters are not contiguous, indicating that there are multiple deletions. EditABLE currently only supports single SNVs, insertions, or deletions.'\n                    else:\n                        current_dash_position = i\n            if start_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence before the desired edit. {start_dash_position} base pairs were found before your edit.\"\n            if len(ref_sequence) - 1 - current_dash_position < 25:\n                return False, f\"There must be at least 25 base pairs of sequence after the desired edit. {len(ref_sequence) - 1 - current_dash_position} base pairs were found after your edit.\"\n    return True, \"Inputs verified. Proceed to get guides.\"\n\n\ndef generate_experimental_validation_section(guides_df, pam_type):\n    # Extract the guide RNAs from the DataFrame\n    guide_rnas = guides_df[\"Base Editing Guide\"].tolist()\n    \n    # Process the guide RNAs\n    processed_guide_rnas = process_guide_rnas(guide_rnas)\n    \n    # Get the cloning URL based on PAM type\n    cloning_id, cloning_url = get_cloning_url(pam_type)\n    \n    # Create the validation section UI elements\n    validation_section = [\n        ui.help_text(\n            ui.tags.span(\"1. Order the following paired oligos from \"),\n            ui.tags.a(\"IDT\", href=\"https://www.idtdna.com\", target=\"_blank\"),\n            ui.tags.span(\" (or other preferred vendor).\")\n        ),\n        ui.br(),\n        ui.br(),\n    ]\n    \n    # Add each processed guide RNA to the validation section\n    for guide_rna in processed_guide_rnas:\n        guide_rna_parts = guide_rna.split('\\n')\n        for part in guide_rna_parts:\n            validation_section.append(ui.help_text(part))\n            validation_section.append(ui.br())\n        validation_section.append(ui.br())  # Add a double space between guide RNAs\n    \n    validation_section.extend([\n        ui.br(),\n        ui.help_text(\n            ui.tags.span(\"2. Purchase Guide RNA cloning plasmid from \"),\n            ui.tags.a(\"Addgene\", href=cloning_url, target=\"_blank\"),\n            ui.tags.span(f\" (Addgene: {cloning_id}).\")\n        ),\n        ui.br(),\n        ui.br(),\n        ui.help_text(\n            ui.tags.span(\"3. Follow Cloning Protocol \"),\n            ui.tags.a(\"here\", href=\"https://media.addgene.org/cms/filer_public/6d/d8/6dd83407-3b07-47db-8adb-4fada30bde8a/zhang-lab-general-cloning-protocol-target-sequencing_1.pdf\", target=\"_blank\"),\n            ui.tags.span(\".\")\n        ),\n    ])\n    \n    return ui_card(\"Experimental Validation of Base Editing Guide RNAs\", 'validation_section', *validation_section)\n\ndef generate_base_editing_visualization(guides_df, ref_sequence_input, substitution_position, PAM):\n    list_of_guides_to_display = []\n    for index, row in guides_df.iterrows():\n        if row['Editing Technology'] == 'Base Editing':\n            guide = row[\"Base Editing Guide\"]\n            orientation = row[\"Base Editing Guide Orientation\"]\n\n            ref_sequence_almost_rc = almost_reverse_complement(ref_sequence_input)\n            base_to_edit = ref_sequence_input[substitution_position] if orientation != 'reverse' else ref_sequence_almost_rc[substitution_position]\n            if orientation == 'reverse':\n                guide = guide[::-1]\n                all_guide_occurance_starts = [m.start() for m in re.finditer(guide, ref_sequence_almost_rc)]\n            else:\n                all_guide_occurance_starts = [m.start() for m in re.finditer(guide, ref_sequence_input)]\n\n            true_starting_positions = []\n            for start in all_guide_occurance_starts:\n                end = start + len(guide) - 1\n                if substitution_position >= start and substitution_position <= end:\n                    true_starting_positions.append(start)\n            assert len(true_starting_positions) == 1, (\"Error! Guide cannot be aligned properly to input original sequence\", guide, ref_sequence_almost_rc, orientation, all_guide_occurance_starts, substitution_position)\n            guide_start = true_starting_positions[0]\n\n            list_of_guides_to_display.append(ui.help_text(f\"Guide {index + 1}\"))\n            list_of_guides_to_display.append(ui.br())\n            if orientation == 'reverse':\n                reverse_guide_rna_with_formatting = []\n                for i in range(len(guide)):\n                    base_position = guide_start + len(guide) - 1 - i\n                    base = ref_sequence_almost_rc[base_position]\n                    if i >= 3 and i < 9:  # Bases 4-9 (0-based index)\n                        if base_position == substitution_position:  # Base to edit\n                            reverse_guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: green; font-family: Courier,courier\"))\n                        elif base == base_to_edit:\n                            reverse_guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: red; font-family: Courier,courier\"))\n                        else:\n                            reverse_guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: violet; font-family: Courier,courier\"))\n                    else:\n                        reverse_guide_rna_with_formatting.append(ui.tags.b(base, style=\"color: violet; font-family: Courier,courier\"))\n\n                list_of_guides_to_display.append(\n                    ui.help_text(\n                        ui.tags.b(\"Forward Strand: 5'-\" + ref_sequence_input[:substitution_position], style=\"font-family: Courier,courier\"),\n                        ui.tags.b(ref_sequence_input[substitution_position], style=\"color: green; font-family: Courier,courier\"),  # base to edit\n                        ui.tags.b(ref_sequence_input[substitution_position + 1:] + \"-3'\", style=\"font-family: Courier,courier\"),\n                    )\n                )\n                list_of_guides_to_display.append(ui.br())\n                list_of_guides_to_display.append(\n                    ui.help_text(\n                        ui.tags.b(\"Reverse Strand: 3'-\" + ref_sequence_almost_rc[:guide_start - len(PAM)], style=\"font-family: Courier,courier\"),\n                        ui.tags.b(ref_sequence_almost_rc[guide_start - len(PAM):guide_start], style=\"color: blue; font-family: Courier,courier\"),  # PAM\n                        *reverse_guide_rna_with_formatting[::-1],  # reverse guide RNA\n                        ui.tags.b(ref_sequence_almost_rc[guide_start + len(guide):] + \"-5'\", style=\"font-family: Courier,courier\"),\n                    )\n                )\n            else:\n                guide_rna_with_formatting = []\n                for i in range(len(guide)):\n                    base = ref_sequence_input[guide_start + i]\n                    if i >= 3 and i < 9:  # Bases 4-9 (0-based index)\n                        if guide_start + i == substitution_position:  # Base to edit\n                            guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: green; font-family: Courier,courier\"))\n                        elif base == base_to_edit:\n                            guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: red; font-family: Courier,courier\"))\n                        else:\n                            guide_rna_with_formatting.append(ui.tags.b(base, style=\"text-decoration: underline; color: violet; font-family: Courier,courier\"))\n                    else:\n                        guide_rna_with_formatting.append(ui.tags.b(base, style=\"color: violet; font-family: Courier,courier\"))\n\n                list_of_guides_to_display.append(\n                    ui.help_text(\n                        ui.tags.b(\"Forward Strand: 5'-\" + ref_sequence_input[:guide_start], style=\"font-family: Courier,courier\"),\n                        *guide_rna_with_formatting,\n                        ui.tags.b(ref_sequence_input[len(guide) + guide_start:len(guide) + guide_start + len(PAM)], style=\"color: blue; font-family: Courier,courier\"),  # PAM\n                        ui.tags.b(ref_sequence_input[guide_start + len(guide) + len(PAM):] + \"-3'\", style=\"font-family: Courier,courier\"),\n                    )\n                )\n                list_of_guides_to_display.append(ui.br())\n                list_of_guides_to_display.append(\n                    ui.help_text(\n                        ui.tags.b(\"Reverse Strand: 3'-\" + ref_sequence_almost_rc[:substitution_position], style=\"font-family: Courier,courier\"),\n                        ui.tags.b(ref_sequence_almost_rc[substitution_position], style=\"color: green; font-family: Courier,courier\"),  # base to edit\n                        ui.tags.b(ref_sequence_almost_rc[substitution_position + 1:] + \"-5'\", style=\"font-family: Courier,courier\"),\n                    )\n                )\n            if index != guides_df.shape[0] - 1:\n                list_of_guides_to_display.append(ui.br())\n                list_of_guides_to_display.append(ui.br())\n    return list_of_guides_to_display\n\n\n\n\ndef server(input, output, session):\n    #Function to get editor info based on PAM and mutation type\n    def get_editor_info(pam_type, mutation_type):\n        return editor_data[mutation_type].get(pam_type, editor_data['PrimeEditor']['default'])\n\n    def input_check(ref_sequence_input, edited_sequence_input):\n        nonlocal input_file\n        if input_file and not (ref_sequence_input or edited_sequence_input):\n            try:\n                df = pd.read_csv(input_file)\n            except:\n                return False, \"Input file is not a properly formed CSV file. Please input a proper CSV file.\"\n\n            if len(df.columns) != 2 or df.columns.tolist() != ['Original Sequence', 'Desired Sequence']:\n                return False, 'Uploaded csv does not have the proper columns. Your csv must have two columns with names \"Original Sequence\" and \"Desired Sequence\"'\n            \n            counter = 1\n            for index, row in df.iterrows():\n                ref_sequence = \"\".join(row['Original Sequence'].split()).upper()\n                edited_sequence = \"\".join(row['Desired Sequence'].split()).upper()\n                check, message = check_ref_edited_pair(ref_sequence, edited_sequence)\n                if not check:\n                    return check, f\"Error row {counter}: {message}\"\n                counter += 1\n            return True, \"Input CSV verified. Proceed to get guides.\"\n        elif ref_sequence_input and edited_sequence_input and not input_file:\n            check, message = check_ref_edited_pair(\"\".join(ref_sequence_input.split()).upper(), \"\".join(edited_sequence_input.split()).upper())\n            return check, message\n        elif ref_sequence_input and edited_sequence_input and input_file:\n            return False, \"Error: Fill in both text input fields or upload a CSV file but do not do both.\"\n        else:\n            return False, \"Error: Fill in both text input fields or upload a CSV file.\"\n    \n    input_file = None\n\n    @output\n    @render.ui\n    @reactive.event(input.upload)\n    def upload():\n        nonlocal input_file\n        file_infos = input.file1()\n        if file_infos:\n            input_file = file_infos[0]['datapath']\n            return ui.div(ui.br(), ui.tags.b(\"File Successfully Uploaded\", style=\"color: grey;\", id='upload_status'))\n        else:\n            return ui.div(ui.br(), ui.tags.b(\"Error: No file selected\", style=\"color: red;\", id='upload_status'))\n\n    @reactive.Effect()\n    def clear():\n        value = input.clear()    \n        if value > 0:\n            ui.update_text_area(\"ref_sequence_input\", value = \"\")\n            ui.update_text_area(\"edited_sequence_input\", value = \"\")\n            ui.update_select(\"pam_type\", selected='NGN')\n            ui.remove_ui(selector=\"div:has(> #results)\")\n            ui.remove_ui(selector=\"div:has(> #upload_status)\")\n\n            nonlocal input_file\n            input_file = None\n\n    @output\n    @render.ui\n    def ui_input_file():\n        input.clear()  \n        return ui.input_file(f\"file1\", 'Choose a CSV File of Sequences to Upload (note that you must click the blue \"Upload File\" button even if the progress bar under the file browser says \"Upload complete\". Also, clicking the button will cause the screen to scroll up to the top which is annoying and we are trying to fix that):', accept='.csv', multiple=False, width=\"100%\"),\n        \n    @output\n    @render.ui\n    @reactive.event(input.get_guides)\n    def run():\n        ref_sequence_input = input.ref_sequence_input()\n        edited_sequence_input = input.edited_sequence_input()\n        PAM = input.pam_type()\n        mutation_type = determine_mutation_type(ref_sequence_input, edited_sequence_input)\n\n        editor_name, editor_id, editor_url = get_editor_info(PAM, mutation_type)\n        editor_info = f\"{editor_name} (Addgene: {editor_id}, {editor_url})\"\n        \n        to_display_guides_df, guides_df = get_guides(ref_sequence_input, edited_sequence_input, PAM)\n        base_editing_guides_df = guides_df[guides_df['Editing Technology'] == 'Base Editing']\n        prime_editing_guides_df = guides_df[guides_df['Editing Technology'] == 'Prime Editing']\n\n        @output\n        @render.data_frame\n        def render_results():\n            nonlocal to_display_guides_df\n            return render.DataGrid(\n                to_display_guides_df,\n                selection_mode='none',\n                width=\"100%\",\n                filters=False,\n                summary=True,\n            )\n\n        @render.download(filename=lambda: f\"guides-{date.today().isoformat()}-{datetime.now().strftime('%H-%M-%S')}.csv\")\n        async def download_results():\n            nonlocal guides_df\n            yield guides_df.to_csv()\n\n        ref_sequence_input = input.ref_sequence_input()\n        edited_sequence_input = input.edited_sequence_input()\n\n        nonlocal input_file\n        valid_inputs, message = input_check(ref_sequence_input, edited_sequence_input)\n        PAM = input.pam_type()\n\n        if valid_inputs:\n            if input_file and not (ref_sequence_input or edited_sequence_input):\n                df = pd.read_csv(input_file)\n                dfs_to_merge_download = list()\n                dfs_to_merge_display = list()\n                counter = 1\n\n                with ui.Progress(min=1, max=df.shape[0] + 1) as p:\n                    p.set(message=\"Finding guides\", detail=\"This may take a while...\")\n                    for index, row in df.iterrows():\n                        p.set(counter, message=\"Finding guides\")\n                        ref_sequence_input = \"\".join(row['Original Sequence'].split()).upper()\n                        edited_sequence_input = \"\".join(row['Desired Sequence'].split()).upper()\n                        to_display_guides_df, guides_df = get_guides(ref_sequence_input, edited_sequence_input, PAM)\n                        index_column = [str(counter)] * to_display_guides_df.shape[0]\n                        to_display_guides_df.insert(loc=0, column='Input CSV Row Number', value=index_column)\n                        dfs_to_merge_download.append(guides_df)\n                        dfs_to_merge_display.append(to_display_guides_df)\n                        counter += 1\n\n                to_display_guides_df = pd.concat(dfs_to_merge_display)\n                to_display_guides_df = to_display_guides_df.drop(columns=['Original Sequence', 'Desired Sequence'])\n                guides_df = pd.concat(dfs_to_merge_download)\n                base_editing_guides_df = guides_df[guides_df['Editing Technology'] == 'Base Editing']\n                \n                ui_elements = [\n                    ui_card(\n                        \"Recommended Guide RNAs\",\n                        'results',\n                        ui.help_text(\n                            \"Note: for base editing, there can be more than one guide RNA for a single desired edit, but for prime editing, we will only show the recommended PrimeDesign guide RNA\"\n                        ),\n                        ui.br(),\n                        ui.br(),\n                        ui.output_data_frame(\"render_results\"),\n                        ui.br(),\n                        ui.br(),\n                    )\n                ]\n                \n                ui_elements.append(ui.download_button(\"download_results\", \"Download Results as CSV File\"))\n                ui_elements.append(ui.br())  # Add this line to insert a line break\n\n                return ui.TagList(*ui_elements)\n            elif ref_sequence_input and edited_sequence_input and not input_file:\n                ref_sequence_input = \"\".join(ref_sequence_input.split()).upper()\n                edited_sequence_input = \"\".join(edited_sequence_input.split()).upper()\n                to_display_guides_df, guides_df = get_guides(ref_sequence_input, edited_sequence_input, PAM)\n                to_display_guides_df = to_display_guides_df.drop(columns=['Original Sequence', 'Desired Sequence'])\n                to_display_guides_df.insert(loc=0, column='Guide', value=[f\"Guide {i + 1}\" for i in range(to_display_guides_df.shape[0])])\n\n                substitution_position = None\n                for i in range(len(ref_sequence_input)):\n                    ref_base = ref_sequence_input[i]\n                    edited_base = edited_sequence_input[i]\n                    if ref_base != edited_base:\n                        substitution_position = i\n                        break\n\n                if len(ref_sequence_input) > 51:\n                    ref_sequence_input = ref_sequence_input[substitution_position - 25:substitution_position + 25 + 1]\n                    substitution_position = 25\n\n                list_of_guides_to_display = generate_base_editing_visualization(guides_df, ref_sequence_input, substitution_position, PAM)\n\n                # Filter for Base Editing or Prime Editing guides only\n                filtered_guides_df = to_display_guides_df[to_display_guides_df['Editing Technology'].isin(['Base Editing', 'Prime Editing'])]\n\n                ui_elements = [\n                    ui_card(\n                        \"Recommended Guide RNAs\",\n                        'results',\n                        ui.help_text(\n                            \"Note: for base editing, there can be more than one guide RNA for a single desired edit, but for prime editing, we will only show the recommended PrimeDesign guide RNA. \"\n                        ),\n                        ui.br(),\n                        ui.br(),\n                        ui.output_data_frame(\"render_results\"),\n                        ui.br(),\n                    )\n                ]\n\n                if not filtered_guides_df.empty:\n                    ui_elements.append(\n                        ui_card(\n                            \"Recommended Editor\",\n                            \"recommended_editor\",\n                            ui.help_text(f\"Selected Editor: {editor_info}\"),\n                            ui.br(),\n                            ui.br(),\n                            ui.tags.a(\"View on Addgene\", href=editor_url, target=\"_blank\", class_=\"btn btn-primary\"),\n                        )\n                    )\n\n                if 'Base Editing' in filtered_guides_df['Editing Technology'].values:\n                    ui_elements.append(\n                        ui_card(\n                            \"Visualization of Base Editing Guides\",\n                            \"base_editing_visualization\",\n                            ui.help_text(\n                                \"For each base editing guide, your input will be displayed with the guide sequence highlighted on the appropriate strand.\",\n                                ui.tags.b(\" Green\", style=\"color: green\"),\n                                \" characters represent your edited base, \", \n                                ui.tags.b(\"blue\", style=\"color: blue\"),\n                                \" characters represent the PAM nucleotides, \",\n                                ui.tags.b(\"violet\", style=\"color: violet\"),\n                                \" characters represent other nucleotides in the guide, \",\n                                ui.tags.b(\"underlined\", style=\"text-decoration: underline\"),\n                                \" characters represent a span for potential bystander edits, and \",\n                                ui.tags.b(\"red\", style= \"color: red\"),\n                                \" characters represent the potential bystander edits, themselves. Grey characters represent nucleotides not spanned by the guide. Only 25 bp of sequence upstream and downstream of the desired edit is shown. NOTE: when toggling the order of the guides, the guide number above corresponds to the guide number within the visualization.\"\n                            ),\n                            ui.br(),\n                            ui.br(),\n                            *list_of_guides_to_display\n                        )\n                    )\n\n                if not base_editing_guides_df.empty:\n                    validation_section = generate_experimental_validation_section(base_editing_guides_df, PAM)\n                    ui_elements.append(validation_section)\n\n                ui_elements.append(ui.download_button(\"download_results\", \"Download Results as CSV File\"))\n                ui_elements.append(ui.br())  # Add this line to insert a line break\n\n                return ui.TagList(*ui_elements)\n        else:\n            return ui.div(ui.tags.b(message, style=\"color: red;\"))\n\n\n    @output\n    @render.image\n    def display_logo():\n        dir = Path(__file__).resolve().parent\n        img: ImgData = {\"src\": str(dir / \"EditABLE-logos_transparent.png\"), \"width\": \"300px\"}\n        return img\n\n    @output\n    @render.image\n    def stanford_logo():\n        dir = Path(__file__).resolve().parent\n        img: ImgData = {\"src\": str(dir / \"SOM_Web_vert_LG.png\"), \"width\": \"300px\"}\n        return img\n\napp = App(app_ui, server)\n"
    },
    {
        "name": "utils.py",
        "content": "import collections\nimport pandas as pd\nimport regex as re\nfrom Bio.Seq import MutableSeq\nfrom Bio.SeqUtils import MeltingTemp as mt\nfrom math import log\nfrom itertools import product, combinations \nimport numpy as np\nimport subprocess, os\nimport numpy as np\nfrom calculate_scores import calculate_on_target_scores, calculate_off_target_scores \n\n\nbases = {\"A\", \"C\", \"G\", \"T\"}\n\nedit_start = 4\nedit_end = 9\ngRNA_size = 20\npam_length = None\nPAMs = None\nreverse_PAMs = None\n\n#helper function to find be guide rnas, pams, and 30 nt sequence\ndef find_BE_guide_rnas(direction, seq, genomic_location):\n    if direction == \"forward\":\n        start_pams = genomic_location + (gRNA_size - edit_end) + 1\n        end_pams = genomic_location + (gRNA_size - edit_start) + pam_length + 1\n        possible_pams = seq[start_pams : end_pams]\n        if len(re.findall(PAMs, str(possible_pams))) == 0:\n            return \"NO PAM\"\n        else:\n            guideRNAs = []\n            pams = []\n            azimuth_sequences = []\n            for match in re.finditer(PAMs, str(possible_pams), overlapped=True):\n                gRNA = seq[start_pams + match.start() - gRNA_size: start_pams + match.start()]\n                pam = possible_pams[match.start(): match.start() + pam_length]\n                guideRNAs.append(str(gRNA))\n                pams.append(str(pam))\n                start_idx = start_pams + match.start() - gRNA_size - 4\n                end_idx = start_pams + match.start() + pam_length + 3\n                azimuth_sequence = seq[start_idx:end_idx]\n                azimuth_sequences.append(str(azimuth_sequence))\n                \n               \n                \n            #azimuth_sequences = update_azimuth_sequences(azimuth_sequences, pam_length)\n            return guideRNAs, pams, azimuth_sequences\n\n    elif direction == \"reverse\":\n        start_pams = genomic_location - gRNA_size + edit_start - pam_length\n        end_pams = genomic_location - gRNA_size + edit_end\n        possible_pams = seq[start_pams : end_pams]\n        if len(re.findall(reverse_PAMs, str(possible_pams))) == 0:\n            return \"NO PAM\"\n        else:\n            guideRNAs = []\n            pams = []\n            azimuth_sequences = []\n            for match in re.finditer(reverse_PAMs, str(possible_pams), overlapped=True):\n                gRNA_start = start_pams + match.start() + pam_length\n                gRNA_end = gRNA_start + gRNA_size\n                gRNA = seq[gRNA_start : gRNA_end]\n                pam = possible_pams[match.start(): match.start() + pam_length]\n                guideRNAs.append(str(gRNA.reverse_complement()))\n                pams.append(str(pam.reverse_complement()))  # Correct the PAM to be the reverse complement\n                start_idx = start_pams + match.start() - 3\n                end_idx = start_pams + match.start() + gRNA_size + pam_length + 4\n                azimuth_sequence = seq[start_idx:end_idx].reverse_complement()\n                azimuth_sequences.append(str(azimuth_sequence))\n                \n            #azimuth_sequences = update_azimuth_sequences(azimuth_sequences, pam_length)\n            return guideRNAs, pams, azimuth_sequences\n    else:\n        return \"ERROR\"\n\n# dictionary for guide rna cloning plasmid\npam_to_url = {\n    \"NNNRRT_NNGRRT_NNGRR\": (70709,  \"https://www.addgene.org/70709\"),\n    \"NGG_NGN_NRN_NYN_NGA\": (140580, \"https://www.addgene.org/140580\")\n}\n\ndef get_cloning_url(pam):\n    pam_patterns = {\n        \"NNNRRT\": \"NNNRRT_NNGRRT_NNGRR\",\n        \"NNGRRT\": \"NNNRRT_NNGRRT_NNGRR\",\n        \"NNGRR\": \"NNNRRT_NNGRRT_NNGRR\",\n        \"NGG\": \"NGG_NGN_NRN_NYN_NGA\",\n        \"NGN\": \"NGG_NGN_NRN_NYN_NGA\",\n        \"NRN\": \"NGG_NGN_NRN_NYN_NGA\",\n        \"NYN\": \"NGG_NGN_NRN_NYN_NGA\",\n        \"NGA\": \"NGG_NGN_NRN_NYN_NGA\"\n    }\n    \n    cloning_group = pam_patterns.get(pam)\n    url = pam_to_url.get(cloning_group)\n    \n    return url\n \n#helper function to track position of base to edit within the guide rna and then return potential bystander edits   \ndef track_positions(guide, ref_sequence_input, substitution_position, orientation):\n    ref_sequence_almost_rc = almost_reverse_complement(ref_sequence_input)\n    base_to_edit = ref_sequence_input[substitution_position] if orientation != 'reverse' else ref_sequence_almost_rc[substitution_position]\n    \n    if orientation == 'reverse':\n        guide = guide[::-1]\n        all_guide_occurance_starts = [m.start() for m in re.finditer(guide, ref_sequence_almost_rc)]\n    else:\n        all_guide_occurance_starts = [m.start() for m in re.finditer(guide, ref_sequence_input)]\n\n    true_starting_positions = []\n    for start in all_guide_occurance_starts:\n        end = start + len(guide) - 1\n        if substitution_position >= start and substitution_position <= end:\n            true_starting_positions.append(start)\n    \n    assert len(true_starting_positions) == 1, (\"Error! Guide cannot be aligned properly to input original sequence\", guide, ref_sequence_almost_rc, orientation, all_guide_occurance_starts, substitution_position)\n    guide_start = true_starting_positions[0]\n\n    if orientation == 'reverse':\n        window_sequence = ref_sequence_almost_rc[guide_start + len(guide) - edit_end: guide_start + len(guide) - edit_start + 1][::-1]\n        actual_base_position = guide_start + len(guide) - substitution_position \n    else:\n        window_sequence = ref_sequence_input[guide_start + edit_start - 1: guide_start + edit_end]\n        actual_base_position = substitution_position - guide_start + 1   # Adjust to 0-based index for the window\n\n    all_positions = [i for i, base in enumerate(window_sequence, start=edit_start) if base == base_to_edit]\n    \n    if actual_base_position in all_positions:\n        all_positions.remove(actual_base_position)\n\n    if len(all_positions) > 0:\n        return f\"Yes (positions: {', '.join(map(str, all_positions))})\"\n    else:\n        return \"No\"\n\n\n\n#helper function for experimental validation of base editing guide rnas\ndef process_guide_rnas(guide_rnas):\n    results = []\n    for guide_rna in guide_rnas:\n        # Replace the first letter with G\n        modified_guide_rna = 'G' + guide_rna[1:]\n        \n        # Generate the reverse complement\n        reverse_guide = str(reverse_complement(modified_guide_rna))\n        \n        # Replace the last letter of the reverse complement with C\n        reverse_complement_modified = reverse_guide[:-1] + 'C'\n        \n        # Format the output\n        result = f\"5' - CACC {modified_guide_rna} - 3'\\n5' - AAAC {reverse_complement_modified} - 3'\"\n        results.append(result)\n    \n    return results\n\n\ndef generate_mutations_to_single_base(guide_rnas, max_mutations=3):\n    bases = {'A', 'C', 'G', 'T'}\n    all_mutated_guides = []\n\n    def mutate_single_position(guide, position, new_base):\n        new_guide = guide[:]\n        new_guide[position] = new_base\n        return ''.join(new_guide)\n\n    for guide_rna in guide_rnas:\n        guide_rna_list = list(guide_rna)\n        for target_base in bases:\n            mutated_guides = []\n            for num_mutations in range(1, max_mutations + 1):\n                for positions in combinations(range(len(guide_rna)), num_mutations):\n                    new_guide = guide_rna_list[:]\n                    for pos in positions:\n                        new_guide[pos] = target_base\n                    mutated_guides.append(''.join(new_guide))\n            all_mutated_guides.extend(mutated_guides)\n\n    return all_mutated_guides\n\ndef calculate_off_target_scores_for_guides(guide_rnas, pams):\n    all_results = []\n\n    for guide_rna, pam in zip(guide_rnas, pams):\n        protospacers = generate_mutations_to_single_base([guide_rna])\n        scores_df = calculate_off_target_scores([guide_rna] * len(protospacers), protospacers, [pam] * len(protospacers))\n        scores_df['guide_rna'] = guide_rna\n        all_results.append(scores_df)\n    \n    combined_scores = pd.concat(all_results)\n\n    # this is to ensure only numeric columns are averaged\n    numeric_columns = combined_scores.select_dtypes(include=[np.number]).columns.tolist()\n    numeric_columns.append('guide_rna')\n\n    average_scores = combined_scores[numeric_columns].groupby('guide_rna').mean().reset_index()\n    average_scores['score'] = 100-(average_scores['score'].round(3)*100)\n\n    return combined_scores, average_scores\n\n\n#Define editor data, dictionary for type of editing enzymes\neditor_data = {\n    'ABE': {\n        'NGN': ('ABE8e-NG enzyme', '138491', 'https://www.addgene.org/138491'),\n        'NGG': ('ABE8e enzyme', '138489', 'https://www.addgene.org/138489'),\n        'NGA': ('ABE8e-NG enzyme', '138491', 'https://www.addgene.org/138491'),\n        'NNGRRT': ('ABE8e-SaCas enzyme', '138500', 'https://www.addgene.org/138500'),\n        'NNNRRT': ('ABE8e-SaCas-KKH enzyme', '138502', 'https://www.addgene.org/138502'),\n        'NRN': ('SpRY', '140003', 'https://www.addgene.org/140003/')\n    },\n    'CBE': {\n        'NGN': ('BE4max-NG', '138159', 'https://www.addgene.org/138159'),\n        'NGG': ('BE4max', '112093', 'https://www.addgene.org/112093'),\n        'NGA': ('BE4max-NG', '138159', 'https://www.addgene.org/138159'),\n        'NNGRRT': ('BE3-SaCas', '85169', 'https://www.addgene.org/85169'),\n        'NNNRRT': ('BE3-SaCas-KKH', '85170', 'https://www.addgene.org/85170'),\n        'NRN' : ('SpRY', '139999', 'https://www.addgene.org/139999/')\n    },\n    'transversion': {\n        'NGN' : ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/' ),\n        'NGG': ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/' ),\n        'NGA': ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/'),\n        'NNGRRT': ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/'),\n        'NNNRRT': ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/'),\n        'NRN' : ('UdgX-HF-nCas9','163559','https://www.addgene.org/163559/')\n    },\n    'PrimeEditor': {\n    'default': ('PE6D', '207854', 'https://www.addgene.org/207854/')\n    },\n}    \n\n#determine the mutation type for the base editors\ndef determine_mutation_type(ref_seq, edited_seq, pams=None):\n    mutation_type = \"PrimeEditor\"  # Default mutation type is PrimeEditor\n    for ref_base, edit_base in zip(ref_seq, edited_seq):\n        if ref_base != edit_base:\n            # Create a mutation identifier from reference and edited bases\n            edit_type = f\"{ref_base}>{edit_base}\"\n            \n            # Determine the type of base editing required based on the mutation\n            if edit_type in [\"A>G\", \"T>C\"]:\n                return \"ABE\"\n            elif edit_type in [\"G>A\", \"C>T\"]:\n                return \"CBE\"\n            elif edit_type in [\"C>G\", \"G>C\"]:\n                return \"transversion\"   \n    return mutation_type \n\n\n\n# Helper function to find guide RNAs for transversion (C>G and G>C) mutations on forward/reverse strands\ndef find_trans_guide_rnas(direction, seq, genomic_location):\n    if direction == \"forward\":\n        pam = seq[genomic_location + 15 : genomic_location + 15 + pam_length]\n        if len(re.findall(PAMs, str(pam))) == 0:\n            return \"NO PAM\"\n        else:\n            return seq[genomic_location + 15 - gRNA_size : genomic_location + 15]\n    elif direction == \"reverse\":\n        pam = seq[genomic_location - 15 - 1: genomic_location - 15 - 1 + pam_length]\n        if len(re.findall(reverse_PAMs, str(pam))) == 0:\n            return \"NO PAM\"\n        else:\n            gRNA = seq[genomic_location - 15 - 1 + pam_length: genomic_location - 15 - 1 + pam_length + gRNA_size]\n            gRNA.reverse_complement(inplace=True)\n            return gRNA\n    else:\n        return \"ERROR\"\n\n\n# Adds the base editable guide RNAs to the data table for export\ndef get_guide_RNAs(mutant_seq, edit_type, genomic_location):\n    try:\n        if edit_type == \"A>G\":\n            result = find_BE_guide_rnas(\"forward\", mutant_seq, genomic_location)\n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"forward\"\n        elif edit_type == \"T>C\":\n            result = find_BE_guide_rnas(\"reverse\", mutant_seq, genomic_location)\n      \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"reverse\"\n        elif edit_type == \"G>A\":\n            result = find_BE_guide_rnas(\"reverse\", mutant_seq, genomic_location)\n           \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"reverse\"\n        elif edit_type == \"C>T\":\n            result = find_BE_guide_rnas(\"forward\", mutant_seq, genomic_location)\n           \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"forward\"\n        elif edit_type == \"G>C\":\n            result = find_trans_guide_rnas(\"forward\", mutant_seq, genomic_location)\n           \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"forward\"\n        elif edit_type == \"C>G\":\n            result = find_trans_guide_rnas(\"reverse\", mutant_seq, genomic_location)\n           \n            if result == \"NO PAM\":\n                return ((\"NO PAM\", None, None), None)\n            return result, \"reverse\"\n        else:\n            return ((\"NOT BASE EDITABLE\", None, None), None)\n    \n    except Exception as e:\n        print(f\"Exception in get_guide_RNAs: {e}\")\n        return ((\"ERROR\", None, None), None)\n\n\n#helper function to set pam sequences: Initialize PAM sequences based on the provided PAM\ndef set_pam_sequences(PAM):\n    global PAMs, reverse_PAMs, pam_length\n    pam_length = len(PAM)\n    if PAM == 'NGN':\n        PAMs = re.compile(\"[A|T|G|C]G[A|T|G|C]\")\n        reverse_PAMs = re.compile(\"[A|T|G|C]C[A|T|G|C]\")\n    elif PAM == 'NGG':\n        PAMs = re.compile(\"[A|T|G|C]GG\")\n        reverse_PAMs = re.compile(\"CC[A|T|G|C]\")\n    elif PAM == 'NGA':\n        PAMs = re.compile(\"[A|T|G|C]GA\")\n        reverse_PAMs = re.compile(\"TC[A|T|G|C]\")\n    elif PAM == 'NNGRRT':\n        PAMs = re.compile(\"[A|T|G|C][A|T|G|C]G[A|G][A|G]T\")\n        reverse_PAMs = re.compile(\"A[T|C][T|C]C[A|T|G|C][A|T|G|C]\")\n    elif PAM == 'NNNRRT':\n        PAMs = re.compile(\"[A|T|G|C][A|T|G|C][A|T|G|C][A|G][A|G]T\")\n        reverse_PAMs = re.compile(\"A[T|C][T|C][A|T|G|C][A|T|G|C][A|T|G|C]\")\n    elif PAM == 'NRN':\n        PAMs = re.compile(\"[A|T|G|C][G|A][A|T|G|C]\")\n        reverse_PAMs = re.compile(\"[A|T|G|C][C|T][A|T|G|C]\")   \n    elif PAM == 'NYN':\n        PAMs = re.compile(\"[A|T|G|C][C|T][A|T|G|C]\")\n        reverse_PAMs = re.compile(\"[A|T|G|C][G|A][A|T|G|C]\")   \n    else:\n        raise ValueError(\"Invalid PAM sequence\")\n \n #helper function to create mutuable seq: Convert input sequences to mutable sequences  \ndef create_mutable_sequences(ref_sequence_original, edited_sequence_original):\n    ref_sequence = MutableSeq(ref_sequence_original)\n    edited_sequence = MutableSeq(edited_sequence_original)\n    return ref_sequence, edited_sequence\n\n#helper function to identify substitution position: Find the position of the substitution in the sequences\ndef identify_substitution_position(ref_sequence, edited_sequence):\n    substitution_position = None\n    for i in range(len(ref_sequence)):\n        ref_base = ref_sequence[i]\n        edited_base = edited_sequence[i]\n        if ref_base != edited_base:\n            substitution_position = i\n            break\n    return substitution_position\n\n#helper function to determine the appropriate guide RNAs based on the mutation type.\ndef get_guide_rnas_and_orientation(ref_sequence, edit, substitution_position):\n    try:\n        result = get_guide_RNAs(ref_sequence, edit, substitution_position)\n\n        if result is None or result[0] is None:\n            raise ValueError(\"Invalid result from get_guide_RNAs\")\n        \n        (guide_rnas, pams, azimuth_sequences), orientation = result\n        \n        return guide_rnas, orientation, pams, azimuth_sequences\n    \n    except ValueError as ve:\n        print(f\"ValueError: {ve}\")\n        print(f\"result: {result}\")\n    except Exception as e:\n        print(f\"Exception: {e}\")\n        print(f\"result: {result}\")\n\n\n#helper function to generate prime design outputs if necessary\ndef run_prime_design(ref_sequence, edited_sequence, substitution_position):\n    primedesign_input = str(ref_sequence[:substitution_position] + f\"({ref_sequence[substitution_position]}/{edited_sequence[substitution_position]})\" + ref_sequence[substitution_position + 1:])\n    primedesign_output = run_primedesign(str(primedesign_input))\n    return primedesign_output\n\n#helper function to handle deletions: process cases where there are insertions.\ndef handle_insertions(ref_sequence, edited_sequence, df_dict, ref_sequence_original, edited_sequence_original):\n    insertion_start = ref_sequence.find('-')\n    insertion_end = ref_sequence.rfind('-')\n    if insertion_end - insertion_start + 1 > 44:\n        add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"Use Twin Prime Editing/Integrase/HDR\")\n    else:\n        primedesign_input = str(ref_sequence[:insertion_start] + f\"(+{edited_sequence[insertion_start : insertion_end + 1]})\" + ref_sequence[insertion_end + 1:])\n        primedesign_output = run_primedesign(primedesign_input)\n        if primedesign_output != \"No PrimeDesign Recommended Guides\":\n            update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, \"Prime Editing\")\n        else:\n            add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"Use Twin Prime Editing/Integrase/HDR\")\n    return df_dict\n\n\n#helper function to handle deletions: process cases where there are deletions.\ndef handle_deletions(ref_sequence, edited_sequence, df_dict, ref_sequence_original, edited_sequence_original):\n    deletion_start = edited_sequence.find('-')\n    deletion_end = edited_sequence.rfind('-')\n    if deletion_start - deletion_end + 1 > 80:\n        add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"Use Twin Prime Editing/Integrase/HDR\")\n    else:\n        primedesign_input = str(ref_sequence[:deletion_start] + f\"(-{ref_sequence[deletion_start : deletion_end + 1]})\" + ref_sequence[deletion_end + 1:])\n        primedesign_output = run_primedesign(primedesign_input)\n        if primedesign_output != \"No PrimeDesign Recommended Guides\":\n            update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, \"Prime Editing\")\n        else:\n            add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"Use Twin Prime Editing/Integrase/HDR\")\n    return df_dict\n\n#helper function to add insertions and deletions\ndef add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, editing_technology):\n    df_dict['Original Sequence'].append(ref_sequence_original)\n    df_dict['Desired Sequence'].append(edited_sequence_original)\n    df_dict['Editing Technology'].append(editing_technology)\n    df_dict['Base Editing Guide'].append(None)\n    df_dict['Off Target Score'].append(None)\n    df_dict['On Target Score'].append(None)\n    df_dict['Bystander Edits?'].append(None)\n    df_dict['PrimeDesign pegRNA Annotation'].append(None)\n    df_dict['PrimeDesign pegRNA PBS'].append(None)\n    df_dict['PrimeDesign pegRNA RTT'].append(None)\n    df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n    df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n    df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n    df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n    df_dict['PrimeDesign ngRNA Annotation'].append(None)\n    df_dict['PrimeDesign ngRNA Distance'].append(None)\n    df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n    df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n\n#helper function to update the dataframe dictionary with prime design output\ndef update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, editing_technology):\n    peg_spacer_top_recommended, peg_spacer_bottom_recommended, peg_ext_top_recommended, peg_ext_bottom_recommended, peg_annotation_recommended, peg_pbs_recommended, peg_rtt_recommended, ng_spacer_top_recommended, ng_spacer_bottom_recommended, ng_annotation_recommended, ng_distance_recommended = primedesign_output\n    df_dict['Original Sequence'].append(ref_sequence_original)\n    df_dict['Desired Sequence'].append(edited_sequence_original)\n    df_dict['Editing Technology'].append(editing_technology)\n    df_dict['Base Editing Guide'].append(None)\n    df_dict['Off Target Score (Click To Toggle)'].append(None)\n    df_dict['On Target Score (Click To Toggle)'].append(None)\n    df_dict['Bystander Edits?'].append(None)\n    df_dict['PrimeDesign pegRNA Annotation'].append(peg_annotation_recommended)\n    df_dict['PrimeDesign pegRNA PBS'].append(peg_pbs_recommended)\n    df_dict['PrimeDesign pegRNA RTT'].append(peg_rtt_recommended)\n    df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(peg_spacer_top_recommended)\n    df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(peg_spacer_bottom_recommended)\n    df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(peg_ext_top_recommended)\n    df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(peg_ext_bottom_recommended)\n    df_dict['PrimeDesign ngRNA Annotation'].append(ng_annotation_recommended)\n    df_dict['PrimeDesign ngRNA Distance'].append(ng_distance_recommended)\n    df_dict['PrimeDesign ngRNA Oligo Top'].append(ng_spacer_top_recommended)\n    df_dict['PrimeDesign ngRNA Bottom Top'].append(ng_spacer_bottom_recommended)\n\n#helper function prepare the data for output as a dataframe\ndef render_dataframe(df_dict):\n    # Ensure all lists in df_dict have the same length\n    max_length = max(len(v) for v in df_dict.values())\n    for key in df_dict.keys():\n        while len(df_dict[key]) < max_length:\n            df_dict[key].append(None)\n    \n    df_dict_render = collections.defaultdict(list)\n    for key in df_dict:\n        if key != 'Base Editing Guide Orientation':\n            for value in df_dict[key]:\n                if key == 'Editing Technology' or key == 'PrimeDesign pegRNA Annotation':\n                    df_dict_render[key].append(value)\n                elif value is None:\n                    df_dict_render[key].append(None)\n                else:\n                    df_dict_render[key].append(value)\n\n    # Create the DataFrame\n    df_render = pd.DataFrame.from_dict(df_dict_render).dropna(how='all', axis=1)\n    df_full = pd.DataFrame.from_dict(df_dict).dropna(how='all', axis=1)\n\n    # Filter out rows where 'Base Editing Guide' is None or empty\n    df_render = df_render[df_render['Base Editing Guide'].notna()]\n    df_render = df_render[df_render['Base Editing Guide'] != '']\n\n    return df_render, df_full\n\n\n\ndef get_guides(ref_sequence_original, edited_sequence_original, PAM):\n    set_pam_sequences(PAM)\n    ref_sequence, edited_sequence = create_mutable_sequences(ref_sequence_original, edited_sequence_original)\n    df_dict = collections.defaultdict(list)\n\n    if len(set(ref_sequence) - bases) == 0:\n        substitution_position = identify_substitution_position(ref_sequence, edited_sequence)\n        edit = f\"{ref_sequence[substitution_position]}>{edited_sequence[substitution_position]}\"\n        guide_rnas, orientation, pams, azimuth_sequences = get_guide_rnas_and_orientation(ref_sequence, edit, substitution_position)\n        protospacers = generate_mutations_to_single_base(guide_rnas)\n\n        if guide_rnas == \"NOT BASE EDITABLE\":\n            primedesign_output = run_prime_design(ref_sequence, edited_sequence, substitution_position)\n            if primedesign_output != \"No PrimeDesign Recommended Guides\":\n                update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, \"Prime Editing\")\n            else:\n                add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"No Base or Prime Editing Guides Found\")\n        elif guide_rnas == \"NO PAM\":\n            # Rerun gRNA finder for base editing with NRN PAM\n            set_pam_sequences('NRN')\n            guide_rnas, orientation, pams, azimuth_sequences = get_guide_rnas_and_orientation(ref_sequence, edit, substitution_position)\n            if guide_rnas == \"NO PAM\":\n                # Rerun gRNA finder for base editing with NYN PAM\n                set_pam_sequences('NYN')\n                guide_rnas, orientation, pams, azimuth_sequences = get_guide_rnas_and_orientation(ref_sequence, edit, substitution_position)\n                if guide_rnas == \"NO PAM\":\n                    primedesign_output = run_prime_design(ref_sequence, edited_sequence, substitution_position)\n                    if primedesign_output != \"No PrimeDesign Recommended Guides\":\n                        update_df_dict_with_primedesign_output(df_dict, ref_sequence_original, edited_sequence_original, primedesign_output, \"Prime Editing\")\n                    else:\n                        add_insertion_deletion_entries(df_dict, ref_sequence_original, edited_sequence_original, \"No Base or Prime Editing Guides Found\")\n                else:\n                    \n                    #calculate off target score\n                    protospacers = generate_mutations_to_single_base(guide_rnas)\n                    if pams == set_pam_sequences(\"NGG\"):\n                        combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, pams)\n                    else:\n                        try:\n                            combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, [\"CGG\"]*len(guide_rnas))\n                            \n                        \n                        except:\n                            print(f\"Error in calculate_off_target_scores: {e}\")\n                            print(f\"Length of spacers: {len(guide_rnas*len(protospacers))}\")\n                            print(f\"Length of protospacers: {len(protospacers)}\")\n\n                            print(f\"Guide RNAs: {guide_rnas}\")\n                            cfd_scores = {'score': [None] * len(guide_rnas)} \n                            \n                 \n                    # Calculate on-target scores\n                    on_target_scores_df = calculate_on_target_scores(azimuth_sequences)\n                    \n                    # Print NYN PAM gRNAs\n                    if not isinstance(guide_rnas, list):\n                        guide_rnas = [guide_rnas]\n                    for gRNA, cfd_score, on_score in zip(guide_rnas, average_scores['score'],on_target_scores_df['score'] ):\n                        position_info = track_positions(gRNA, ref_sequence_original, substitution_position, orientation)\n                        \n                        df_dict['Original Sequence'].append(ref_sequence_original)\n                        df_dict['Desired Sequence'].append(edited_sequence_original)\n                        df_dict['Editing Technology'].append(\"Base Editing\") #with NYN PAM\n                        df_dict['Base Editing Guide'].append(str(gRNA))\n                        df_dict['Base Editing Guide Orientation'].append(orientation)\n                        df_dict['Off Target Score (Click To Toggle)'].append(cfd_score)\n                        df_dict['On Target Score (Click To Toggle)'].append(on_score)\n                        df_dict['Bystander Edits?'].append(position_info)\n                        df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                        df_dict['PrimeDesign pegRNA PBS'].append(None)\n                        df_dict['PrimeDesign pegRNA RTT'].append(None)\n                        df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                        df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                        df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                        df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                        df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                        df_dict['PrimeDesign ngRNA Distance'].append(None)\n                        df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                        df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n            else:   \n                #calculate off target score\n                \n                protospacers = generate_mutations_to_single_base(guide_rnas)\n                if pams == set_pam_sequences(\"NGG\"):\n                    combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, pams)\n\n                else:\n                    try:\n                        combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, [\"CGG\"]*len(guide_rnas))\n                        \n                        \n                    except Exception as e:\n                        print(f\"Error in calculate_off_target_scores: {e}\")\n                        print(f\"Length of spacers: {len(guide_rnas*len(protospacers))}\")\n                        print(f\"Length of protospacers: {len(protospacers)}\")\n\n                        print(f\"Guide RNAs: {guide_rnas}\")\n                        cfd_scores = {'score': [None] * len(guide_rnas)} \n                \n               \n                # Calculate on-target scores\n                on_target_scores_df = calculate_on_target_scores(azimuth_sequences)\n                # Print NRN PAM gRNAs\n                if not isinstance(guide_rnas, list):\n                    guide_rnas = [guide_rnas]\n                for gRNA, cfd_score, on_score in zip(guide_rnas, average_scores['score'],on_target_scores_df['score'] ):\n                    position_info = track_positions(gRNA, ref_sequence_original, substitution_position, orientation)\n                    \n                    df_dict['Original Sequence'].append(ref_sequence_original)\n                    df_dict['Desired Sequence'].append(edited_sequence_original)\n                    df_dict['Editing Technology'].append(\"Base Editing\") #with nrn pam\n                    df_dict['Base Editing Guide'].append(str(gRNA))\n                    df_dict['Base Editing Guide Orientation'].append(orientation)\n                    df_dict['Base Editing Guide Orientation'].append(orientation)\n                    df_dict['Off Target Score (Click To Toggle)'].append(cfd_score)\n                    df_dict['On Target Score (Click To Toggle)'].append(on_score)\n                    df_dict['Bystander Edits?'].append(position_info)\n                    df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                    df_dict['PrimeDesign pegRNA PBS'].append(None)\n                    df_dict['PrimeDesign pegRNA RTT'].append(None)\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                    df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                    df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                    df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                    df_dict['PrimeDesign ngRNA Distance'].append(None)\n                    df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                    df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n        else:\n            \n            #calculate off target score\n            protospacers = generate_mutations_to_single_base(guide_rnas)\n            if pams == set_pam_sequences(\"NGG\"):\n                combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, pams)\n               \n            else:    \n                try:\n                    combined_scores, average_scores = calculate_off_target_scores_for_guides(guide_rnas, [\"CGG\"]*len(guide_rnas))\n                    \n                   \n                except Exception as e:\n                    print(f\"Error in calculate_off_target_scores: {e}\")\n                    print(f\"Length of spacers: {len(guide_rnas*len(protospacers))}\")\n                    print(f\"Length of protospacers: {len(protospacers)}\")\n\n                    print(f\"Guide RNAs: {guide_rnas}\")\n                    cfd_scores = {'score': [None] * len(guide_rnas)} \n            \n            \n            # Calculate on-target scores\n            on_target_scores_df = calculate_on_target_scores(azimuth_sequences)\n            \n            # Print original PAM gRNAs\n            if not isinstance(guide_rnas, list):\n                guide_rnas = [guide_rnas]\n            for gRNA, cfd_score, on_score in zip(guide_rnas, average_scores['score'],on_target_scores_df['score'] ):\n                position_info = track_positions(gRNA, ref_sequence_original, substitution_position, orientation)\n                \n                df_dict['Original Sequence'].append(ref_sequence_original)\n                df_dict['Desired Sequence'].append(edited_sequence_original)\n                df_dict['Editing Technology'].append(\"Base Editing\")\n                df_dict['Base Editing Guide'].append(str(gRNA))\n                df_dict['Base Editing Guide Orientation'].append(orientation)\n                df_dict['Off Target Score (Click To Toggle)'].append(cfd_score)\n                df_dict['On Target Score (Click To Toggle)'].append(on_score)\n                df_dict['Bystander Edits?'].append(position_info)\n                df_dict['PrimeDesign pegRNA Annotation'].append(None)\n                df_dict['PrimeDesign pegRNA PBS'].append(None)\n                df_dict['PrimeDesign pegRNA RTT'].append(None)\n                df_dict['PrimeDesign pegRNA Spacer Oligo Top'].append(None)\n                df_dict['PrimeDesign pegRNA Spacer Oligo Bottom'].append(None)\n                df_dict['PrimeDesign pegRNA Extension Oligo Top'].append(None)\n                df_dict['PrimeDesign pegRNA Extension Oligo Bottom'].append(None)\n                df_dict['PrimeDesign ngRNA Annotation'].append(None)\n                df_dict['PrimeDesign ngRNA Distance'].append(None)\n                df_dict['PrimeDesign ngRNA Oligo Top'].append(None)\n                df_dict['PrimeDesign ngRNA Bottom Top'].append(None)\n\n    elif '-' in ref_sequence:\n        df_dict = handle_insertions(ref_sequence, edited_sequence, df_dict, ref_sequence_original, edited_sequence_original)\n        \n    elif '-' in edited_sequence:\n        df_dict = handle_deletions(ref_sequence, edited_sequence, df_dict, ref_sequence_original, edited_sequence_original)\n\n    return render_dataframe(df_dict) \n\n# Helper functions\ndef gc_content(sequence):\n    sequence = sequence.upper()\n    GC_count = sequence.count('G') + sequence.count('C')\n    GC_content = float(GC_count)/float(len(sequence))\n\n    return(\"%.2f\" % GC_content)\n\n# IUPAC code map\niupac2bases_dict = {'A':'A','T':'T','C':'C','G':'G','a':'a','t':'t','c':'c','g':'g',\n'R':'[AG]','Y':'[CT]','S':'[GC]','W':'[AT]','K':'[GT]','M':'[AC]','B':'[CGT]','D':'[AGT]','H':'[ACT]','V':'[ACG]','N':'[ACTG]',\n'r':'[ag]','y':'[ct]','s':'[gc]','w':'[at]','k':'[gt]','m':'[ac]','b':'[cgt]','d':'[agt]','h':'[act]','v':'[acg]','n':'[actg]',\n'(':'(',')':')','+':'+','-':'-','/':'/'}\n\ndef iupac2bases(iupac):\n\n    try:\n        bases = iupac2bases_dict[iupac]\n    except:\n        logger.error('Symbol %s is not within the IUPAC nucleotide code ...' % str(iupac))\n        sys.exit(1)\n\n    return(bases)\n\n# Reverse complement function\ndef reverse_complement(sequence):\n    sequence = sequence\n    new_sequence = ''\n    for base in sequence:\n        if base == 'A':\n            new_sequence += 'T'\n        elif base == 'T':\n            new_sequence += 'A'\n        elif base == 'C':\n            new_sequence += 'G'\n        elif base == 'G':\n            new_sequence += 'C'\n        elif base == 'a':\n            new_sequence += 't'\n        elif base == 't':\n            new_sequence += 'a'\n        elif base == 'c':\n            new_sequence += 'g'\n        elif base == 'g':\n            new_sequence += 'c'\n        elif base == '[':\n            new_sequence += ']'\n        elif base == ']':\n            new_sequence += '['\n        elif base == '+':\n            new_sequence += '+'\n        elif base == '-':\n            new_sequence += '-'\n        elif base == '/':\n            new_sequence += '/'\n        elif base == '(':\n            new_sequence += ')'\n        elif base == ')':\n            new_sequence += '('\n    return(new_sequence[::-1])\n\ndef almost_reverse_complement(sequence):\n    sequence = sequence\n    new_sequence = ''\n    for base in sequence:\n        if base == 'A':\n            new_sequence += 'T'\n        elif base == 'T':\n            new_sequence += 'A'\n        elif base == 'C':\n            new_sequence += 'G'\n        elif base == 'G':\n            new_sequence += 'C'\n        elif base == 'a':\n            new_sequence += 't'\n        elif base == 't':\n            new_sequence += 'a'\n        elif base == 'c':\n            new_sequence += 'g'\n        elif base == 'g':\n            new_sequence += 'c'\n        elif base == '[':\n            new_sequence += ']'\n        elif base == ']':\n            new_sequence += '['\n        elif base == '+':\n            new_sequence += '+'\n        elif base == '-':\n            new_sequence += '-'\n        elif base == '/':\n            new_sequence += '/'\n        elif base == '(':\n            new_sequence += ')'\n        elif base == ')':\n            new_sequence += '('\n    return new_sequence\n\n# Extract reference and edited sequence information\ndef process_sequence(input_sequence):\n\n    input_sequence = ''.join(input_sequence.split())\n\n    # Check formatting is correct\n    format_check = ''\n    for i in input_sequence:\n        if i == '(':\n            format_check += '('\n        elif i == ')':\n            format_check += ')'\n        elif i == '/':\n            format_check += '/'\n        elif i == '+':\n            format_check += '+'\n        elif i == '-':\n            format_check += '-'\n\n    # Check composition of input sequence\n    if len(input_sequence) != sum([1 if x in ['A','T','C','G','(',')','+','-','/'] else 0 for x in input_sequence.upper()]):\n        assert False\n\n    # Check formatting\n    if format_check.count('(') == format_check.count(')') and format_check.count('(') > 0: # Left and right parantheses equal\n        if '((' not in format_check: # Checks both directions for nested parantheses\n            if '()' not in format_check: # Checks for empty annotations\n                if sum([1 if x in format_check else 0 for x in ['++','--','//','+-','+/','-+','-/','/+','/-','/(','+(','-(',')/',')+',')-']]) == 0:\n                    pass\n\n    # Create mapping between input format and reference and edit sequence\n    editformat2sequence = {}\n    edits = re.findall('\\(.*?\\)', input_sequence)\n    for edit in edits:\n        if '/' in edit:\n            editformat2sequence[edit] = [edit.split('/')[0].replace('(',''), edit.split('/')[1].replace(')','')]\n        elif '+' in edit:\n            editformat2sequence[edit] = ['' , edit.split('+')[1].replace(')','')]\n        elif '-' in edit:\n            editformat2sequence[edit] = [edit.split('-')[1].replace(')',''), '']\n\n    # Create mapping between edit number and reference and edit sequence\n    editformat2sequence = {}\n    editnumber2sequence = {}\n    edit_idxs = [[m.start(), m.end()] for m in re.finditer('\\(.*?\\)', input_sequence)]\n    edit_counter = 1\n    for edit_idx in edit_idxs:\n        edit = input_sequence[edit_idx[0]:edit_idx[1]]\n\n        # Create edit format and number to sequence map\n        if '/' in edit:\n            editformat2sequence[edit] = [edit.split('/')[0].replace('(',''), edit.split('/')[1].replace(')','').lower(), edit_counter]\n            editnumber2sequence[edit_counter] = [edit.split('/')[0].replace('(',''), edit.split('/')[1].replace(')','').lower()]\n\n        elif '+' in edit:\n            editformat2sequence[edit] = ['' , edit.split('+')[1].replace(')','').lower(), edit_counter]\n            editnumber2sequence[edit_counter] = ['' , edit.split('+')[1].replace(')','').lower()]\n\n        elif '-' in edit:\n            editformat2sequence[edit] = [edit.split('-')[1].replace(')',''), '', edit_counter]\n            editnumber2sequence[edit_counter] = [edit.split('-')[1].replace(')',''), '']\n\n        edit_counter += 1\n\n    edit_start = min([i.start() for i in re.finditer('\\(', input_sequence)])\n    edit_stop = max([i.start() for i in re.finditer('\\)', input_sequence)])\n\n    edit_span_sequence_w_ref = input_sequence[edit_start:edit_stop + 1]\n    edit_span_sequence_w_edit = input_sequence[edit_start:edit_stop + 1]\n    for edit in editformat2sequence:\n        edit_span_sequence_w_ref = edit_span_sequence_w_ref.replace(edit, editformat2sequence[edit][0])\n        edit_span_sequence_w_edit = edit_span_sequence_w_edit.replace(edit, editformat2sequence[edit][1])\n\n    edit_start_in_ref = re.search('\\(', input_sequence).start()\n    edit_stop_in_ref_rev = re.search('\\)', input_sequence[::-1]).start()\n\n    edit_span_length_w_ref = len(edit_span_sequence_w_ref)\n    edit_span_length_w_edit = len(edit_span_sequence_w_edit)\n\n    reference_sequence = input_sequence\n    edit_sequence = input_sequence\n    editnumber_sequence = input_sequence\n    for edit in editformat2sequence:\n        reference_sequence = reference_sequence.replace(edit, editformat2sequence[edit][0])\n        edit_sequence = edit_sequence.replace(edit, editformat2sequence[edit][1])\n        editnumber_sequence = editnumber_sequence.replace(edit, str(editformat2sequence[edit][2]))\n\n    return(editformat2sequence, editnumber2sequence, reference_sequence, edit_sequence, editnumber_sequence, edit_span_length_w_ref, edit_span_length_w_edit, edit_start_in_ref, edit_stop_in_ref_rev)\n\ndef run_primedesign(input_sequence):\n    target_design = {}\n    peg_design = {'pegRNA group':[],'type':[], 'spacer sequence':[],'spacer GC content':[],'PAM':[],'strand':[],'peg-to-edit distance':[],'nick-to-peg distance':[],'pegRNA extension':[], 'extension first base':[],'PBS length':[],'PBS GC content':[], 'PBS Tm':[], 'RTT length':[],'RTT GC content':[],'annotation':[],'spacer top strand oligo':[], 'spacer bottom strand oligo':[], 'pegRNA extension top strand oligo':[], 'pegRNA extension bottom strand oligo':[], 'CFD score':[]}\n\n    input_sequence = ''.join(input_sequence.split())\n    pe_format = 'NNNNNNNNNNNNNNNNN/NNN[NGG]'\n    \n    pbs_length_list = list(range(12, 15))\n    rtt_length_list = list(range(10, 21))\n\n    if 80 not in rtt_length_list:\n        rtt_length_list.append(80)\n        rtt_length_list = sorted(rtt_length_list)\n\n    nicking_distance_minimum = 0\n    nicking_distance_maximum = 100\n\n    target_sequence = input_sequence\n    target_name = 'user-input'\n\n    target_sequence = target_sequence.upper()\n    editformat2sequence, editnumber2sequence, reference_sequence, edit_sequence, editnumber_sequence, edit_span_length_w_ref, edit_span_length_w_edit, edit_start_in_ref, edit_stop_in_ref_rev = process_sequence(target_sequence)\n\n    # Initialize dictionary for the design of pegRNA spacers for each target sequence and intended edit(s)\n    target_design[target_name] = {'target_sequence':target_sequence, 'editformat2sequence': editformat2sequence, 'editnumber2sequence': editnumber2sequence, 'reference_sequence': reference_sequence, 'edit_sequence': edit_sequence, 'editnumber_sequence': editnumber_sequence, 'edit_span_length': [edit_span_length_w_ref, edit_span_length_w_edit], 'edit_start_in_ref': edit_start_in_ref, 'edit_stop_in_ref_rev': edit_stop_in_ref_rev, 'pegRNA':{'+':[], '-':[]}, 'ngRNA':{'+':[], '-':[]}}\n\n    # Find indices but shift when removing annotations\n    cut_idx = re.search('/', pe_format).start()\n    pam_start_idx = re.search('\\[', pe_format).start()\n    pam_end_idx = re.search('\\]', pe_format).start()\n\n    # Find pam and total PE format search length\n    pam_length = pam_end_idx - pam_start_idx - 1\n    pe_format_length = len(pe_format) - 3\n\n    # Check if cut site is left of PAM\n    if cut_idx < pam_start_idx:\n\n        # Shift indices with removal of annotations\n        pam_start_idx = pam_start_idx - 1\n        pam_end_idx = pam_end_idx - 2\n        spacer_start_idx = 0\n        spacer_end_idx = pam_start_idx\n\n    else:\n        pam_end_idx = pam_end_idx - 1\n        cut_idx = cut_idx - 2\n        spacer_start_idx = pam_end_idx\n        spacer_end_idx = len(pe_format) - 3\n\n    # Remove annotations and convert into regex\n    pe_format_rm_annotation = pe_format.replace('/', '').replace('[', '').replace(']', '')\n\n    # Create PE format and PAM search sequences\n    pe_format_search_plus = ''\n    for base in pe_format_rm_annotation:\n        pe_format_search_plus += iupac2bases(base)\n    pe_format_search_minus = reverse_complement(pe_format_search_plus)\n\n    pam_search = ''\n    pam_sequence = pe_format_rm_annotation[pam_start_idx:pam_end_idx]\n    for base in pam_sequence:\n        pam_search += iupac2bases(base)\n\n    ##### Initialize data storage for output\n    counter = 1\n    for target_name in target_design:\n\n        # pegRNA spacer search for (+) and (-) strands with reference sequence\n        reference_sequence = target_design[target_name]['reference_sequence']\n        find_guides_ref_plus = [[m.start()] for m in re.finditer('(?=%s)' % pe_format_search_plus, reference_sequence, re.IGNORECASE)]\n        find_guides_ref_minus = [[m.start()] for m in re.finditer('(?=%s)' % pe_format_search_minus, reference_sequence, re.IGNORECASE)]\n\n        # pegRNA spacer search for (+) and (-) strands with edit number sequence\n        editnumber_sequence = target_design[target_name]['editnumber_sequence']\n        find_guides_editnumber_plus = [[m.start()] for m in re.finditer('(?=%s)' % pam_search.replace('[', '[123456789'), editnumber_sequence, re.IGNORECASE)]\n        find_guides_editnumber_minus = [[m.start()] for m in re.finditer('(?=%s)' % reverse_complement(pam_search).replace('[', '[123456789'), editnumber_sequence, re.IGNORECASE)]\n\n        # Find pegRNA spacers targeting (+) strand\n        if find_guides_ref_plus:\n\n            for match in find_guides_ref_plus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = reference_sequence[match[0]:match[0] + pe_format_length]\n                spacer_sequence = full_search[spacer_start_idx:spacer_end_idx]\n                extension_core_sequence = full_search[:cut_idx]\n                downstream_sequence_ref = full_search[cut_idx:]\n                downstream_sequence_length = len(downstream_sequence_ref)\n                pam_ref = full_search[pam_start_idx:pam_end_idx]\n\n                # Check to see if the extended non target strand is conserved in the edited strand\n                try:\n                    extension_core_start_idx, extension_core_end_idx = re.search(extension_core_sequence, edit_sequence).start(), re.search(extension_core_sequence, edit_sequence).end()\n                    downstream_sequence_edit = edit_sequence[extension_core_end_idx:extension_core_end_idx + downstream_sequence_length]\n                    pam_edit = edit_sequence[extension_core_start_idx:extension_core_start_idx + pe_format_length][pam_start_idx:pam_end_idx]\n                    \n                    ## Annotate pegRNA\n                    # Check if PAM is mutated relative to reference sequence\n                    if pam_ref == pam_edit.upper():\n                        pe_annotate = 'PAM_intact'\n\n                    else:\n                        # Check to see if mutation disrupts degenerate base positions within PAM\n                        if re.search(pam_search, pam_edit.upper()):\n                            pe_annotate = 'PAM_intact'\n\n                        else:\n                            pe_annotate = 'PAM_disrupted'\n\n                    # Store pegRNA spacer\n                    nick_ref_idx = match[0] + cut_idx\n                    nick_edit_idx = extension_core_start_idx + cut_idx\n                    target_design[target_name]['pegRNA']['+'].append([nick_ref_idx, nick_edit_idx, full_search, spacer_sequence, pam_ref, pam_edit, pe_annotate])\n\n                except:\n                    continue\n\n        # Find pegRNA spacers targeting (-) strand\n        if find_guides_ref_minus:\n\n            for match in find_guides_ref_minus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = reference_sequence[match[0]:match[0] + pe_format_length]\n                spacer_sequence = full_search[pe_format_length - spacer_end_idx:pe_format_length - spacer_start_idx]\n                extension_core_sequence = full_search[pe_format_length - cut_idx:]\n                downstream_sequence_ref = full_search[:pe_format_length - cut_idx]\n                downstream_sequence_length = len(downstream_sequence_ref)\n                pam_ref = full_search[pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n\n                # Check to see if the extended non target strand is conserved in the edited strand\n                try:\n                    extension_core_start_idx, extension_core_end_idx = re.search(extension_core_sequence, edit_sequence).start(), re.search(extension_core_sequence, edit_sequence).end()\n                    downstream_sequence_edit = edit_sequence[extension_core_start_idx - downstream_sequence_length:extension_core_start_idx]\n                    pam_edit = edit_sequence[extension_core_end_idx - pe_format_length:extension_core_end_idx][pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n                    \n                    ## Annotate pegRNA\n                    # Check if PAM is mutated relative to reference sequence\n                    if pam_ref == pam_edit.upper():\n                        pe_annotate = 'PAM_intact'\n\n                    else:\n                        # Check to see if mutation disrupts degenerate base positions within PAM\n                        if re.search(reverse_complement(pam_search), pam_edit.upper()):\n                            pe_annotate = 'PAM_intact'\n\n                        else:\n                            pe_annotate = 'PAM_disrupted'\n\n                    # Store pegRNA spacer\n                    nick_ref_idx = match[0] + (pe_format_length - cut_idx)\n                    nick_edit_idx = extension_core_start_idx - downstream_sequence_length + (pe_format_length - cut_idx)\n                    target_design[target_name]['pegRNA']['-'].append([nick_ref_idx, nick_edit_idx, full_search, spacer_sequence, pam_ref, pam_edit, pe_annotate])\n\n                except:\n                    continue\n\n        # Find ngRNA spacers targeting (+) strand\n        if find_guides_editnumber_plus:\n\n            for match in find_guides_editnumber_plus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = editnumber_sequence[:match[0] + pam_length]\n                \n                full_search2ref = full_search\n                full_search2edit = full_search\n                for edit_number in editnumber2sequence:\n                    full_search2ref = full_search2ref.replace(str(edit_number), editnumber2sequence[edit_number][0])\n                    full_search2edit = full_search2edit.replace(str(edit_number), editnumber2sequence[edit_number][1])\n\n                if len(full_search2edit[-pe_format_length:]) == pe_format_length:\n\n                    # Identify ngRNA sequence information from edit sequence\n                    full_search_edit = full_search2edit[-pe_format_length:]\n                    spacer_sequence_edit = full_search_edit[spacer_start_idx:spacer_end_idx]\n                    pam_edit = full_search_edit[pam_start_idx:pam_end_idx]\n\n                    # Use reference sequence to find nick index\n                    full_search_ref = full_search2ref[-pe_format_length:]\n                    spacer_sequence_ref = full_search_ref[spacer_start_idx:spacer_end_idx]\n                    pam_ref = full_search_ref[pam_start_idx:pam_end_idx]\n\n                    # Annotate ngRNA\n                    if spacer_sequence_edit.upper() == spacer_sequence_ref.upper():\n                        ng_annotate = 'PE3'\n                    else:\n                        if spacer_sequence_edit.upper()[-10:] == spacer_sequence_ref.upper()[-10:]:\n                            ng_annotate = 'PE3b-nonseed'\n                        else:\n                            ng_annotate = 'PE3b-seed'\n\n                    # Store ngRNA spacer\n                    nick_ref_idx = re.search(full_search_ref, reference_sequence).end() - (pe_format_length - cut_idx)\n                    nick_edit_start_idx = re.search(spacer_sequence_edit, edit_sequence).start()\n                    nick_edit_end_idx = re.search(spacer_sequence_edit, edit_sequence).end()\n                    target_design[target_name]['ngRNA']['+'].append([nick_ref_idx, nick_edit_start_idx, nick_edit_end_idx, full_search_edit, spacer_sequence_edit, pam_edit, ng_annotate])\n\n        # Find ngRNA spacers targeting (-) strand\n        if find_guides_editnumber_minus:\n\n            for match in find_guides_editnumber_minus:\n\n                # Extract matched sequences and annotate type of prime editing\n                full_search = editnumber_sequence[match[0]:]\n                \n                full_search2ref = full_search\n                full_search2edit = full_search\n                for edit_number in editnumber2sequence:\n                    full_search2ref = full_search2ref.replace(str(edit_number), editnumber2sequence[edit_number][0])\n                    full_search2edit = full_search2edit.replace(str(edit_number), editnumber2sequence[edit_number][1])\n\n                if len(full_search2edit[:pe_format_length]) == pe_format_length:\n\n                    # Identify ngRNA sequence information from edit sequence\n                    full_search_edit = full_search2edit[:pe_format_length]\n                    spacer_sequence_edit = full_search_edit[pe_format_length - spacer_end_idx:pe_format_length - spacer_start_idx]\n                    pam_edit = full_search_edit[pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n\n                    # Use reference sequence to find nick index\n                    full_search_ref = full_search2ref[:pe_format_length]\n                    spacer_sequence_ref = full_search_ref[pe_format_length - spacer_end_idx:pe_format_length - spacer_start_idx]\n                    pam_ref = full_search_ref[pe_format_length - pam_end_idx:pe_format_length - pam_start_idx]\n\n                    # Annotate ngRNA\n                    if spacer_sequence_edit.upper() == spacer_sequence_ref.upper():\n                        ng_annotate = 'PE3'\n                    else:\n                        if spacer_sequence_edit.upper()[:10] == spacer_sequence_ref.upper()[:10]:\n                            ng_annotate = 'PE3b-nonseed'\n                        else:\n                            ng_annotate = 'PE3b-seed'\n\n                    # Store ngRNA spacer\n                    nick_ref_idx = re.search(full_search_ref, reference_sequence).start() + (pe_format_length - cut_idx)\n                    nick_edit_start_idx = re.search(spacer_sequence_edit, edit_sequence).start()\n                    nick_edit_end_idx = re.search(spacer_sequence_edit, edit_sequence).end()\n                    target_design[target_name]['ngRNA']['-'].append([nick_ref_idx, nick_edit_start_idx, nick_edit_end_idx, full_search_edit, spacer_sequence_edit, pam_edit, ng_annotate])\n\n        # Grab index information of edits to introduce to target sequence\n        edit_start_in_ref = int(target_design[target_name]['edit_start_in_ref'])\n        edit_stop_in_ref_rev = int(target_design[target_name]['edit_stop_in_ref_rev'])\n        edit_span_length_w_ref = int(target_design[target_name]['edit_span_length'][0])\n        edit_span_length_w_edit = int(target_design[target_name]['edit_span_length'][1])\n\n        # Design pegRNAs targeting the (+) strand\n        counter = 1\n        counted = []\n        for peg_plus in target_design[target_name]['pegRNA']['+']:\n\n            pe_nick_ref_idx, pe_nick_edit_idx, pe_full_search, pe_spacer_sequence, pe_pam_ref, pe_pam_edit, pe_annotate = peg_plus\n            pegid = '_'.join(map(str, [pe_nick_ref_idx, pe_spacer_sequence, pe_pam_ref, pe_annotate, '+']))\n\n            pe_annotate_constant = pe_annotate\n\n            # See if pegRNA spacer can introduce all edits\n            nick2edit_length = edit_start_in_ref - pe_nick_ref_idx\n            if nick2edit_length >= 0:\n\n                # Loop through RTT lengths\n                silent_mutation_edit = ''\n                for rtt_length in rtt_length_list:\n\n                    # See if RT length can reach entire edit\n                    nick2lastedit_length = nick2edit_length + edit_span_length_w_edit\n                    if nick2lastedit_length < rtt_length:\n\n                        # Loop through PBS lengths\n                        for pbs_length in pbs_length_list:\n                            pe_pam_ref_silent_mutation = ''\n\n                            # Construct pegRNA extension to encode intended edit(s)\n                            if ((len(edit_sequence) - pe_nick_edit_idx) - rtt_length) < 0:\n                                rtt_length = len(edit_sequence) - pe_nick_edit_idx\n\n                            # Patch for NGG PAMs - may need to build something more generalizable in the future\n                            pegRNA_ext = reverse_complement(edit_sequence[pe_nick_edit_idx - pbs_length:pe_nick_edit_idx + rtt_length])\n\n                            # Check to see if pegRNA extension is within input sequence\n                            if len(pegRNA_ext) == (pbs_length + rtt_length):\n\n                                peg_design['pegRNA group'].append(counter)\n                                peg_design['type'].append('pegRNA')\n                                peg_design['spacer sequence'].append(pe_spacer_sequence)\n                                peg_design['spacer GC content'].append(gc_content(pe_spacer_sequence))\n\n                                if pe_pam_ref_silent_mutation == '':\n                                    peg_design['PAM'].append(pe_pam_ref)\n                                else:\n                                    peg_design['PAM'].append(pe_pam_ref_silent_mutation)\n\n                                peg_design['strand'].append('+')\n                                peg_design['peg-to-edit distance'].append(nick2lastedit_length)\n                                peg_design['nick-to-peg distance'].append('')\n                                peg_design['pegRNA extension'].append(pegRNA_ext)\n                                peg_design['extension first base'].append(pegRNA_ext[0])\n                                peg_design['PBS length'].append(pbs_length)\n                                peg_design['PBS GC content'].append(gc_content(pegRNA_ext[rtt_length:]))\n                                peg_design['PBS Tm'].append(mt.Tm_NN(pegRNA_ext[-pbs_length:], nn_table=mt.R_DNA_NN1))\n                                peg_design['RTT length'].append(rtt_length)\n                                peg_design['RTT GC content'].append(gc_content(pegRNA_ext[:rtt_length]))\n                                peg_design['annotation'].append(pe_annotate)\n                                peg_design['CFD score'].append('')\n\n                                if pe_spacer_sequence[0] == 'G':\n                                    peg_design['spacer top strand oligo'].append('cacc' + pe_spacer_sequence + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement(pe_spacer_sequence))\n\n                                else:\n                                    peg_design['spacer top strand oligo'].append('caccG' + pe_spacer_sequence + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement('G' + pe_spacer_sequence))\n\n                                peg_design['pegRNA extension top strand oligo'].append('gtgc' + pegRNA_ext)\n                                peg_design['pegRNA extension bottom strand oligo'].append('aaaa' + reverse_complement(pegRNA_ext))\n\n                                counted.append(counter)\n\n                # Create ngRNAs targeting (-) strand for (+) pegRNAs\n                if counter in counted:\n                    for ng_minus in target_design[target_name]['ngRNA']['-']:\n                        ng_nick_ref_idx, ng_edit_start_idx, ng_edit_end_idx, ng_full_search_edit, ng_spacer_sequence_edit, ng_pam_edit, ng_annotate = ng_minus\n                        nick_distance = ng_nick_ref_idx - pe_nick_ref_idx\n\n                        if (abs(nick_distance) >= nicking_distance_minimum) and (abs(nick_distance) <= nicking_distance_maximum):\n\n                            peg_design['pegRNA group'].append(counter)\n                            peg_design['type'].append('ngRNA')\n                            peg_design['spacer sequence'].append(reverse_complement(ng_spacer_sequence_edit))\n                            peg_design['spacer GC content'].append(gc_content(reverse_complement(ng_spacer_sequence_edit)))\n                            peg_design['PAM'].append(reverse_complement(ng_pam_edit))\n                            peg_design['strand'].append('-')\n                            peg_design['peg-to-edit distance'].append('')\n                            peg_design['nick-to-peg distance'].append(nick_distance)\n                            peg_design['pegRNA extension'].append('')\n                            peg_design['extension first base'].append('')\n                            peg_design['PBS length'].append('')\n                            peg_design['PBS GC content'].append('')\n                            peg_design['PBS Tm'].append('')\n                            peg_design['RTT length'].append('')\n                            peg_design['RTT GC content'].append('')\n                            peg_design['annotation'].append(ng_annotate)\n                            peg_design['CFD score'].append('')\n\n                            if reverse_complement(ng_spacer_sequence_edit)[0] == 'G':\n                                peg_design['spacer top strand oligo'].append('cacc' + reverse_complement(ng_spacer_sequence_edit))\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement(reverse_complement(ng_spacer_sequence_edit)))\n\n                            else:\n                                peg_design['spacer top strand oligo'].append('caccG' + reverse_complement(ng_spacer_sequence_edit))\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement('G' + reverse_complement(ng_spacer_sequence_edit)))\n\n                            peg_design['pegRNA extension top strand oligo'].append('')\n                            peg_design['pegRNA extension bottom strand oligo'].append('')\n\n                    counter += 1\n\n        # Design pegRNAs targeting the (-) strand\n        for peg_minus in target_design[target_name]['pegRNA']['-']:\n\n            pe_nick_ref_idx, pe_nick_edit_idx, pe_full_search, pe_spacer_sequence, pe_pam_ref, pe_pam_edit, pe_annotate = peg_minus\n            pegid = '_'.join(map(str, [pe_nick_ref_idx, pe_spacer_sequence, pe_pam_ref, pe_annotate, '-']))\n\n            pe_annotate_constant = pe_annotate\n\n            # See if pegRNA spacer can introduce all edits\n            nick2edit_length = edit_stop_in_ref_rev - (len(reference_sequence) - pe_nick_ref_idx)\n            if nick2edit_length >= 0:\n\n                # Loop through RTT lengths\n                silent_mutation_edit = ''\n                for rtt_length in rtt_length_list:\n\n                    # See if RT length can reach entire edit\n                    nick2lastedit_length = nick2edit_length + edit_span_length_w_edit\n                    if nick2lastedit_length < rtt_length:\n\n                        # Loop through PBS lengths\n                        for pbs_length in pbs_length_list:\n                            pe_pam_ref_silent_mutation = ''\n\n                            # Construct pegRNA extension to encode intended edit(s)\n                            # pegRNA_ext = edit_sequence[pe_nick_edit_idx - rtt_length:pe_nick_edit_idx + pbs_length]\n                            if (pe_nick_edit_idx - rtt_length) < 0:\n                                rtt_length = pe_nick_edit_idx\n\n                            # Patch for NGG PAMs - may need to build something more generalizable in the future\n                            pegRNA_ext = edit_sequence[pe_nick_edit_idx - rtt_length:pe_nick_edit_idx + pbs_length]\n\n                            # Check to see if pegRNA extension is within input sequence\n                            if len(pegRNA_ext) == (pbs_length + rtt_length):\n\n                                peg_design['pegRNA group'].append(counter)\n                                peg_design['type'].append('pegRNA')\n                                peg_design['spacer sequence'].append(reverse_complement(pe_spacer_sequence))\n                                peg_design['spacer GC content'].append(gc_content(reverse_complement(pe_spacer_sequence)))\n\n                                if pe_pam_ref_silent_mutation == '':\n                                    peg_design['PAM'].append(reverse_complement(pe_pam_ref))\n                                else:\n                                    peg_design['PAM'].append(pe_pam_ref_silent_mutation)\n\n                                peg_design['strand'].append('-')\n                                peg_design['peg-to-edit distance'].append(nick2lastedit_length)\n                                peg_design['nick-to-peg distance'].append('')\n                                peg_design['pegRNA extension'].append(pegRNA_ext)\n                                peg_design['extension first base'].append(pegRNA_ext[0])\n                                peg_design['PBS length'].append(pbs_length)\n                                peg_design['PBS GC content'].append(gc_content(pegRNA_ext[rtt_length:]))\n                                peg_design['PBS Tm'].append(mt.Tm_NN(pegRNA_ext[-pbs_length:], nn_table=mt.R_DNA_NN1))\n                                peg_design['RTT length'].append(rtt_length)\n                                peg_design['RTT GC content'].append(gc_content(pegRNA_ext[:rtt_length]))\n                                peg_design['annotation'].append(pe_annotate)\n                                peg_design['CFD score'].append('')\n\n                                if reverse_complement(pe_spacer_sequence)[0] == 'G':\n                                    peg_design['spacer top strand oligo'].append('cacc' + reverse_complement(pe_spacer_sequence) + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement(reverse_complement(pe_spacer_sequence)))\n\n                                else:\n                                    peg_design['spacer top strand oligo'].append('caccG' + reverse_complement(pe_spacer_sequence) + 'gtttt')\n                                    peg_design['spacer bottom strand oligo'].append('ctctaaaac' + reverse_complement('G' + reverse_complement(pe_spacer_sequence)))\n\n                                peg_design['pegRNA extension top strand oligo'].append('gtgc' + pegRNA_ext)\n                                peg_design['pegRNA extension bottom strand oligo'].append('aaaa' + reverse_complement(pegRNA_ext))\n\n                                counted.append(counter)\n\n                # Create ngRNAs targeting (+) strand for (-) pegRNAs\n                if counter in counted:\n                    for ng_plus in target_design[target_name]['ngRNA']['+']:\n                        ng_nick_ref_idx, ng_edit_start_idx, ng_edit_end_idx, ng_full_search_edit, ng_spacer_sequence_edit, ng_pam_edit, ng_annotate = ng_plus\n                        nick_distance = ng_nick_ref_idx - pe_nick_ref_idx\n\n                        if (abs(nick_distance) >= nicking_distance_minimum) and (abs(nick_distance) <= nicking_distance_maximum):\n\n                            peg_design['pegRNA group'].append(counter)\n                            peg_design['type'].append('ngRNA')\n                            peg_design['spacer sequence'].append(ng_spacer_sequence_edit)\n                            peg_design['spacer GC content'].append(gc_content(ng_spacer_sequence_edit))\n                            peg_design['PAM'].append(ng_pam_edit)\n                            peg_design['strand'].append('+')\n                            peg_design['peg-to-edit distance'].append('')\n                            peg_design['nick-to-peg distance'].append(nick_distance)\n                            peg_design['pegRNA extension'].append('')\n                            peg_design['extension first base'].append('')\n                            peg_design['PBS length'].append('')\n                            peg_design['PBS GC content'].append('')\n                            peg_design['PBS Tm'].append('')\n                            peg_design['RTT length'].append('')\n                            peg_design['RTT GC content'].append('')\n                            peg_design['annotation'].append(ng_annotate)\n                            peg_design['CFD score'].append('')\n\n                            if ng_spacer_sequence_edit[0] == 'G':\n                                peg_design['spacer top strand oligo'].append('cacc' + ng_spacer_sequence_edit)\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement(ng_spacer_sequence_edit))\n\n                            else:\n                                peg_design['spacer top strand oligo'].append('caccG' + ng_spacer_sequence_edit)\n                                peg_design['spacer bottom strand oligo'].append('aaac' + reverse_complement('G' + ng_spacer_sequence_edit))\n\n                            peg_design['pegRNA extension top strand oligo'].append('')\n                            peg_design['pegRNA extension bottom strand oligo'].append('')\n\n                    counter += 1\n\n    df = pd.DataFrame.from_dict(peg_design)\n\n    try:\n        df = df[~df['spacer sequence'].str.contains('TTTT')]\n    except:\n        pass\n\n    df_pegs = df[df['type'] == 'pegRNA']\n\n    # Find recommended pegRNA\n    if len(df_pegs.sort_values(['annotation', 'peg-to-edit distance'])['pegRNA group']) > 0:\n\n        edit_effective_length = max([edit_span_length_w_ref, edit_span_length_w_edit])\n        if edit_effective_length <= 1:\n            homology_downstream_recommended = 9\n        elif edit_effective_length <= 5:\n            homology_downstream_recommended = 14\n        elif edit_effective_length <= 10:\n            homology_downstream_recommended = 19\n        elif edit_effective_length <= 15:\n            homology_downstream_recommended = 24\n        else:\n            homology_downstream_recommended = 34\n\n        pegrna_group = df_pegs.sort_values(['annotation', 'peg-to-edit distance'])['pegRNA group'].values[0]\n        rtt_length_recommended = min(df_pegs[df_pegs['pegRNA group'] == pegrna_group]['peg-to-edit distance']) + homology_downstream_recommended\n        rtt_max = max(df_pegs[(df_pegs['pegRNA group'] == pegrna_group)]['RTT length'].values)\n\n        # find recommended PBS\n        df_pegs['recommended_PBS_Tm'] = abs(df_pegs['PBS Tm'] - 37) # optimal PBS Tm of 37C\n        pbs_length_recommended = df_pegs[df_pegs['pegRNA group'] == pegrna_group].sort_values(['recommended_PBS_Tm'], ascending = [True])['PBS length'].values[0]\n\n        # find recommended RTT\n        extension_first_base = 'C'\n        while (extension_first_base == 'C') and (rtt_length_recommended < rtt_max):\n            rtt_length_recommended += 1\n            extension_first_base = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['pegRNA extension'].values[0][rtt_max-int(rtt_length_recommended):rtt_max][0]\n\n        if extension_first_base != 'C':\n\n            pbs_extension_recommended = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['pegRNA extension'].values[0][rtt_max:]\n            rtt_extension_max = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['pegRNA extension'].values[0][:rtt_max]\n            extension_recommended = rtt_extension_max[-rtt_length_recommended:] + pbs_extension_recommended\n\n            peg_spacer_top_recommended = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['spacer top strand oligo'].values[0]\n            peg_spacer_bottom_recommended = df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['spacer bottom strand oligo'].values[0]\n            peg_ext_top_recommended = 'gtgc' + extension_recommended\n            peg_ext_bottom_recommended = 'aaaa' + reverse_complement(extension_recommended)\n\n            peg_annotation_recommended = ' %s' % str(df_pegs[(df_pegs['pegRNA group'] == pegrna_group) & (df_pegs['PBS length'] == pbs_length_recommended) & (df_pegs['RTT length'] == rtt_max)]['annotation'].values[0]).replace('_', ' ')\n            peg_pbs_recommended = '%s nt' % str(pbs_length_recommended)\n            peg_rtt_recommended = '%s nt' % str(rtt_length_recommended)\n\n            # Find recommended ngRNA\n            df_ngs = df[(df['type'] == 'ngRNA') & (df['pegRNA group'] == pegrna_group)]\n            df_ngs['optimal_distance'] = abs(abs(df_ngs['nick-to-peg distance']) - 75) # optimal ngRNA +/- 75 bp away\n            df_ngs = df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True]) # prioritize PE3b\n\n            if len(df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['spacer top strand oligo']) > 0:\n\n                ng_spacer_top_recommended = df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['spacer top strand oligo'].values[0]\n                ng_spacer_bottom_recommended = df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['spacer bottom strand oligo'].values[0]\n                ng_annotation_recommended = ' %s' % str(df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['annotation'].values[0]).replace('_', ' ')\n                ng_distance_recommended = ' %s bp' % str(df_ngs.sort_values(['annotation', 'optimal_distance'], ascending = [False, True])['nick-to-peg distance'].values[0])\n\n            else:\n\n                ng_spacer_top_recommended = 'n/a'\n                ng_spacer_bottom_recommended = 'n/a'\n                ng_annotation_recommended = 'n/a'\n                ng_distance_recommended = 'n/a'\n\n        else:\n\n            peg_spacer_top_recommended = 'n/a'\n            peg_spacer_bottom_recommended = 'n/a'\n            peg_ext_top_recommended = 'n/a'\n            peg_ext_bottom_recommended = 'n/a'\n\n            peg_annotation_recommended = ' n/a'\n            peg_pbs_recommended = ' n/a'\n            peg_rtt_recommended = ' n/a'\n\n            ng_spacer_top_recommended = 'n/a'\n            ng_spacer_bottom_recommended = 'n/a'\n            ng_annotation_recommended = ' n/a'\n            ng_distance_recommended = ' n/a'\n\n    else:\n\n        peg_spacer_top_recommended = ''\n        peg_spacer_bottom_recommended = ''\n        peg_ext_top_recommended = ''\n        peg_ext_bottom_recommended = ''\n\n        peg_annotation_recommended = ''\n        peg_pbs_recommended = ''\n        peg_rtt_recommended = ''\n\n        ng_spacer_top_recommended = ''\n        ng_spacer_bottom_recommended = ''\n        ng_annotation_recommended = ''\n        ng_distance_recommended = ''\n\n    '''\n    # Filter dataframes\n    df = df[(df['extension first base'] != 'C')]\n\n    pbs_range_list = list(range(12, 14 + 1)) + ['']\n    rtt_range_list = list(range(10, 20 + 1)) + ['']\n\n    pegrna_groups_to_keep = list(set(df_pegs[df_pegs['RTT length'].isin(rtt_range_list)]['pegRNA group'].values))\n\n    df = df[df['PBS length'].isin(pbs_range_list)]\n    df_pegs = df_pegs[df_pegs['PBS length'].isin(pbs_range_list)]\n\n    df = df[df['RTT length'].isin(rtt_range_list)]\n    df_pegs = df_pegs[df_pegs['RTT length'].isin(rtt_range_list)]\n\n    df = df[df['pegRNA group'].isin(pegrna_groups_to_keep)]\n    df_pegs = df_pegs[df_pegs['pegRNA group'].isin(pegrna_groups_to_keep)]\n\n    df.reset_index(drop=True, inplace=True)\n\n    df_pegs = df_pegs[['pegRNA group','spacer sequence','PAM','strand','peg-to-edit distance','spacer GC content','annotation']].drop_duplicates()\n    df_pegs = df_pegs.sort_values('peg-to-edit distance')\n    df_pegs.reset_index(drop=True, inplace=True)\n    #return df_pegs, df, peg_spacer_top_recommended, peg_spacer_bottom_recommended, peg_ext_top_recommended, peg_ext_bottom_recommended, peg_annotation_recommended, peg_pbs_recommended, peg_rtt_recommended, ng_spacer_top_recommended, ng_spacer_bottom_recommended, ng_annotation_recommended, ng_distance_recommended\n    '''\n    if peg_spacer_top_recommended == '' and peg_spacer_bottom_recommended == '' and peg_ext_top_recommended == '' and peg_ext_bottom_recommended == '' and peg_annotation_recommended == '' and peg_pbs_recommended == '' and peg_rtt_recommended == '' and ng_spacer_top_recommended == '' and ng_spacer_bottom_recommended == '' and ng_annotation_recommended == '' and ng_distance_recommended == '':\n        return \"No PrimeDesign Recommended Guides\"\n    elif peg_spacer_top_recommended == 'n/a' and peg_spacer_bottom_recommended == 'n/a' and peg_ext_top_recommended == 'n/a' and peg_ext_bottom_recommended == 'n/a' and peg_annotation_recommended == ' n/a' and peg_pbs_recommended == ' n/a' and peg_rtt_recommended == ' n/a' and ng_spacer_top_recommended == 'n/a' and ng_spacer_bottom_recommended == 'n/a' and ng_annotation_recommended == ' n/a' and ng_distance_recommended == ' n/a':\n        return \"No PrimeDesign Recommended Guides\"\n    else:\n        return (peg_spacer_top_recommended, peg_spacer_bottom_recommended, peg_ext_top_recommended, peg_ext_bottom_recommended, peg_annotation_recommended, peg_pbs_recommended, peg_rtt_recommended, ng_spacer_top_recommended, ng_spacer_bottom_recommended, ng_annotation_recommended, ng_distance_recommended)\n"
    },
    {
        "name": "calculate_scores.py",
        "content": "import math\nfrom typing import List, Tuple\nimport argparse\nfrom typing import Dict, Tuple\nimport pandas as pd\n\n# Parameters for on target scoring\nparams: List[Tuple[int, str, float]] = [\n    (1, 'G', -0.2753771), (2, 'A', -0.3238875), (2, 'C', 0.17212887), (3, 'C', -0.1006662),\n    (4, 'C', -0.2018029), (4, 'G', 0.24595663), (5, 'A', 0.03644004), (5, 'C', 0.09837684),\n    (6, 'C', -0.7411813), (6, 'G', -0.3932644), (11, 'A', -0.466099), (14, 'A', 0.08537695),\n    (14, 'C', -0.013814), (15, 'A', 0.27262051), (15, 'C', -0.1190226), (15, 'T', -0.2859442),\n    (16, 'A', 0.09745459), (16, 'G', -0.1755462), (17, 'C', -0.3457955), (17, 'G', -0.6780964),\n    (18, 'A', 0.22508903), (18, 'C', -0.5077941), (19, 'G', -0.4173736), (19, 'T', -0.054307),\n    (20, 'G', 0.37989937), (20, 'T', -0.0907126), (21, 'C', 0.05782332), (21, 'T', -0.5305673),\n    (22, 'T', -0.8770074), (23, 'C', -0.8762358), (23, 'G', 0.27891626), (23, 'T', -0.4031022),\n    (24, 'A', -0.0773007), (24, 'C', 0.28793562), (24, 'T', -0.2216372), (27, 'G', -0.6890167),\n    (27, 'T', 0.11787758), (28, 'C', -0.1604453), (29, 'G', 0.38634258), (1, 'GT', -0.6257787),\n    (4, 'GC', 0.30004332), (5, 'AA', -0.8348362), (5, 'TA', 0.76062777), (6, 'GG', -0.4908167),\n    (11, 'GG', -1.5169074), (11, 'TA', 0.7092612), (11, 'TC', 0.49629861), (11, 'TT', -0.5868739),\n    (12, 'GG', -0.3345637), (13, 'GA', 0.76384993), (13, 'GC', -0.5370252), (16, 'TG', -0.7981461),\n    (18, 'GG', -0.6668087), (18, 'TC', 0.35318325), (19, 'CC', 0.74807209), (19, 'TG', -0.3672668),\n    (20, 'AC', 0.56820913), (20, 'CG', 0.32907207), (20, 'GA', -0.8364568), (20, 'GG', -0.7822076),\n    (21, 'TC', -1.029693), (22, 'CG', 0.85619782), (22, 'CT', -0.4632077), (23, 'AA', -0.5794924),\n    (23, 'AG', 0.64907554), (24, 'AG', -0.0773007), (24, 'CG', 0.28793562), (24, 'TG', -0.2216372),\n    (26, 'GT', 0.11787758), (28, 'GG', -0.69774)\n]\n\n#  mismatch scores and PAM scores dictionaries for off target scoring \nmismatch_scores: Dict[str, float] = {\n    'rU:dT,12': 0.8, 'rU:dT,13': 0.692307692, 'rU:dC,5': 0.64,\n    'rG:dA,14': 0.266666667, 'rG:dG,19': 0.448275862, 'rG:dG,18': 0.476190476,\n    'rG:dG,15': 0.272727273, 'rG:dG,14': 0.428571429, 'rG:dG,17': 0.235294118,\n    'rG:dG,16': 0.0, 'rC:dC,20': 0.058823529, 'rG:dT,20': 0.9375,\n    'rG:dG,13': 0.421052632, 'rG:dG,12': 0.529411765, 'rU:dC,6': 0.571428571,\n    'rU:dG,14': 0.285714286, 'rU:dT,18': 0.666666667, 'rA:dG,13': 0.210526316,\n    'rA:dG,12': 0.263157895, 'rA:dG,11': 0.4, 'rA:dG,10': 0.333333333,\n    'rA:dA,19': 0.538461538, 'rA:dA,18': 0.5, 'rA:dG,15': 0.272727273,\n    'rA:dG,14': 0.214285714, 'rA:dA,15': 0.2, 'rA:dA,14': 0.533333333,\n    'rA:dA,17': 0.133333333, 'rA:dA,16': 0.0, 'rA:dA,11': 0.307692308,\n    'rA:dA,10': 0.882352941, 'rA:dA,13': 0.3, 'rA:dA,12': 0.333333333,\n    'rG:dA,13': 0.3, 'rG:dA,12': 0.384615385, 'rG:dA,11': 0.384615385,\n    'rG:dA,10': 0.8125, 'rG:dA,17': 0.25, 'rG:dA,16': 0.0, 'rG:dA,15': 0.142857143,\n    'rG:dA,6': 0.666666667, 'rG:dG,20': 0.428571429, 'rG:dA,19': 0.666666667,\n    'rG:dA,18': 0.666666667, 'rU:dC,4': 0.625, 'rG:dT,12': 0.933333333,\n    'rG:dT,13': 0.923076923, 'rU:dG,11': 0.666666667, 'rC:dA,3': 0.6875,\n    'rC:dA,2': 0.909090909, 'rC:dA,1': 1.0, 'rC:dA,7': 0.8125,\n    'rC:dA,6': 0.928571429, 'rC:dA,5': 0.636363636, 'rC:dA,4': 0.8,\n    'rC:dA,9': 0.875, 'rC:dA,8': 0.875, 'rU:dT,6': 0.866666667,\n    'rA:dG,20': 0.227272727, 'rG:dT,18': 0.692307692, 'rU:dG,10': 0.533333333,\n    'rG:dT,19': 0.714285714, 'rG:dA,20': 0.7, 'rC:dT,20': 0.5,\n    'rU:dC,2': 0.84, 'rG:dG,10': 0.4, 'rC:dA,17': 0.466666667,\n    'rC:dA,16': 0.307692308, 'rC:dA,15': 0.066666667, 'rC:dA,14': 0.733333333,\n    'rC:dA,13': 0.7, 'rC:dA,12': 0.538461538, 'rC:dA,11': 0.307692308,\n    'rC:dA,10': 0.941176471, 'rG:dG,11': 0.428571429, 'rU:dC,20': 0.176470588,\n    'rG:dG,3': 0.384615385, 'rC:dA,19': 0.461538462, 'rC:dA,18': 0.642857143,\n    'rU:dG,17': 0.705882353, 'rU:dG,16': 0.666666667, 'rU:dG,15': 0.272727273,\n    'rG:dG,2': 0.692307692, 'rU:dG,13': 0.789473684, 'rU:dG,12': 0.947368421,\n    'rG:dA,9': 0.533333333, 'rG:dA,8': 0.625, 'rG:dA,7': 0.571428571,\n    'rG:dG,5': 0.785714286, 'rG:dA,5': 0.3, 'rG:dA,4': 0.363636364,\n    'rG:dA,3': 0.5, 'rG:dA,2': 0.636363636, 'rG:dA,1': 1.0,\n    'rG:dG,4': 0.529411765, 'rG:dG,1': 0.714285714, 'rA:dC,9': 0.666666667,\n    'rG:dG,7': 0.6875, 'rG:dT,5': 0.866666667, 'rU:dT,20': 0.5625,\n    'rC:dC,15': 0.05, 'rC:dC,14': 0.0, 'rC:dC,17': 0.058823529,\n    'rC:dC,16': 0.153846154, 'rC:dC,11': 0.25, 'rC:dC,10': 0.388888889,\n    'rC:dC,13': 0.136363636, 'rC:dC,12': 0.444444444, 'rC:dA,20': 0.3,\n    'rC:dC,19': 0.125, 'rC:dC,18': 0.133333333, 'rA:dA,1': 1.0,\n    'rA:dA,3': 0.705882353, 'rA:dA,2': 0.727272727, 'rA:dA,5': 0.363636364,\n    'rA:dA,4': 0.636363636, 'rA:dA,7': 0.4375, 'rA:dA,6': 0.714285714,\n    'rA:dA,9': 0.6, 'rA:dA,8': 0.428571429, 'rU:dG,20': 0.090909091,\n    'rC:dC,9': 0.619047619, 'rC:dC,8': 0.642857143, 'rU:dT,10': 0.857142857,\n    'rU:dT,11': 0.75, 'rU:dT,16': 0.909090909, 'rU:dT,17': 0.533333333,\n    'rU:dT,14': 0.619047619, 'rU:dT,15': 0.578947368, 'rC:dC,1': 0.913043478,\n    'rU:dT,3': 0.714285714, 'rC:dC,3': 0.5, 'rC:dC,2': 0.695652174,\n    'rC:dC,5': 0.6, 'rC:dC,4': 0.5, 'rC:dC,7': 0.470588235,\n    'rC:dC,6': 0.5, 'rU:dT,4': 0.476190476, 'rU:dT,8': 0.8,\n    'rU:dT,9': 0.928571429, 'rA:dC,19': 0.375, 'rA:dC,18': 0.4,\n    'rA:dC,17': 0.176470588, 'rA:dC,16': 0.192307692, 'rA:dC,15': 0.65,\n    'rA:dC,14': 0.466666667, 'rA:dC,13': 0.652173913, 'rA:dC,12': 0.722222222,\n    'rA:dC,11': 0.65, 'rA:dC,10': 0.555555556, 'rU:dC,7': 0.588235294,\n    'rC:dT,8': 0.65, 'rC:dT,9': 0.857142857, 'rC:dT,6': 0.928571429,\n    'rC:dT,7': 0.75, 'rC:dT,4': 0.842105263, 'rC:dT,5': 0.571428571,\n    'rC:dT,2': 0.727272727, 'rC:dT,3': 0.866666667, 'rC:dT,1': 1.0,\n    'rA:dC,8': 0.733333333, 'rU:dT,1': 1.0, 'rU:dC,3': 0.5,\n    'rU:dC,1': 0.956521739, 'rU:dT,2': 0.846153846, 'rU:dG,19': 0.275862069,\n    'rG:dT,14': 0.75, 'rG:dT,15': 0.941176471, 'rG:dT,16': 1.0,\n    'rG:dT,17': 0.933333333, 'rG:dT,10': 0.933333333, 'rG:dT,11': 1.0,\n    'rA:dG,9': 0.571428571, 'rA:dG,8': 0.428571429, 'rA:dG,7': 0.4375,\n    'rA:dG,6': 0.454545455, 'rA:dG,5': 0.5, 'rA:dG,4': 0.352941176,\n    'rA:dG,3': 0.428571429, 'rA:dG,2': 0.785714286, 'rA:dG,1': 0.857142857,\n    'rU:dT,5': 0.5, 'rG:dT,2': 0.846153846, 'rA:dC,3': 0.611111111,\n    'rA:dC,20': 0.764705882, 'rG:dT,1': 0.9, 'rG:dT,6': 1.0,\n    'rG:dT,7': 1.0, 'rG:dT,4': 0.9, 'rC:dT,19': 0.428571429,\n    'rG:dG,9': 0.538461538, 'rG:dG,8': 0.615384615, 'rG:dT,8': 1.0,\n    'rG:dT,9': 0.642857143, 'rU:dG,18': 0.428571429, 'rU:dT,7': 0.875,\n    'rG:dG,6': 0.681818182, 'rA:dA,20': 0.6, 'rU:dC,9': 0.619047619,\n    'rA:dG,17': 0.176470588, 'rU:dC,8': 0.733333333, 'rA:dG,16': 0.0,\n    'rA:dG,19': 0.206896552, 'rG:dT,3': 0.75, 'rU:dG,3': 0.428571429,\n    'rU:dG,2': 0.857142857, 'rU:dG,1': 0.857142857, 'rA:dG,18': 0.19047619,\n    'rU:dG,7': 0.6875, 'rU:dG,6': 0.909090909, 'rU:dG,5': 1.0,\n    'rU:dG,4': 0.647058824, 'rU:dG,9': 0.923076923, 'rU:dG,8': 1.0,\n    'rU:dC,19': 0.25, 'rU:dC,18': 0.333333333, 'rU:dC,13': 0.260869565,\n    'rU:dC,12': 0.5, 'rU:dC,11': 0.4, 'rU:dC,10': 0.5,\n    'rU:dC,17': 0.117647059, 'rU:dC,16': 0.346153846, 'rU:dC,15': 0.05,\n    'rU:dC,14': 0.0, 'rC:dT,10': 0.866666667, 'rC:dT,11': 0.75,\n    'rC:dT,12': 0.714285714, 'rC:dT,13': 0.384615385, 'rC:dT,14': 0.35,\n    'rC:dT,15': 0.222222222, 'rC:dT,16': 1.0, 'rC:dT,17': 0.466666667,\n    'rC:dT,18': 0.538461538, 'rA:dC,2': 0.8, 'rA:dC,1': 1.0,\n    'rA:dC,7': 0.705882353, 'rA:dC,6': 0.714285714, 'rA:dC,5': 0.72,\n    'rA:dC,4': 0.625, 'rU:dT,19': 0.285714286,\n}\n\npam_scores: Dict[str, float] = {\n    'AA': 0.0, 'AC': 0.0, 'GT': 0.016129032, 'AG': 0.259259259,\n    'CC': 0.0, 'CA': 0.0, 'CG': 0.107142857, 'TT': 0.0,\n    'GG': 1.0, 'GC': 0.022222222, 'AT': 0.0, 'GA': 0.069444444,\n    'TG': 0.038961039, 'TA': 0.0, 'TC': 0.0, 'CT': 0.0,\n}\n\nintercept = 0.59763615\ngcHigh = -0.1665878\ngcLow = -0.2026259\n\ndef calculate_on_target_scores(seqs: List[str]) -> pd.DataFrame:\n    scores = []\n    for seq in seqs:\n        score = intercept\n        guide_seq = seq[4:24]\n        gc_count = guide_seq.count(\"G\") + guide_seq.count(\"C\")\n        if gc_count <= 10:\n            gc_weight = gcLow\n        else:\n            gc_weight = gcHigh\n        score += abs(10 - gc_count) * gc_weight\n\n        for pos, model_seq, weight in params:\n            sub_seq = seq[pos:pos + len(model_seq)]\n            if sub_seq == model_seq:\n                score += weight\n        Score = 1.0 / (1.0 + math.exp(-score))\n        scores.append((seq, Score))\n    \n    # Create a DataFrame for the results\n    on_target_scores_df = pd.DataFrame(scores, columns=['sequence', 'score'])\n    on_target_scores_df['score'] = on_target_scores_df['score'].round(3)*100\n    return on_target_scores_df\n\n\n\n\n\n#Everything below is in relation to off target scoring\ndef get_parser() -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser(description='Calculates CFD score')\n    parser.add_argument('--wt', type=str, required=True, help='WT 23mer sgRNA sequence')\n    parser.add_argument('--off', type=str, required=True, help='Off-target 23mer sgRNA sequence')\n    return parser\n\n# Reverse complements a given string\ndef revcom(s: str) -> str:\n    basecomp = {'A': 'T', 'C': 'G', 'G': 'C', 'T': 'A', 'U': 'A'}\n    letters = [basecomp[base] for base in s[::-1]]\n    return ''.join(letters)\n\n\ndef calculate_off_target_scores(wt_sequences: List[str], sg_sequences: List[str], pam_sequences: List[str]) -> pd.DataFrame:\n    scores = []\n    for wt, sg, pam in zip(wt_sequences, sg_sequences, pam_sequences):\n        score = 1.0\n        sg = sg.replace('T', 'U')\n        wt = wt.replace('T', 'U')\n        s_list = list(sg)\n        wt_list = list(wt)\n\n        for i, sl in enumerate(s_list):\n            if wt_list[i] == sl:\n                score *= 1\n            else:\n                key = f'r{wt_list[i]}:d{revcom(sl)},{i+1}'\n                score *= mismatch_scores.get(key, 1.0)\n\n        score *= pam_scores.get(pam, 1.0)\n        scores.append((wt, sg, pam, score))\n\n    # Create a DataFrame for the results\n    cfd_scores_df = pd.DataFrame(scores, columns=['spacer', 'protospacer', 'pam', 'score'])\n    \n    return cfd_scores_df\n\n\n"
    }
]